<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libacfutils: acfutils/vector.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libacfutils
   </div>
   <div id="projectbrief">A general purpose library of utility functions designed to make it easier to develop addons for the X-Plane flight simulator.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2f18166f86af4fcbeaddefb60d5355e9.html">acfutils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">vector.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="optional_8h_source.html">acfutils/optional.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="sysmacros_8h_source.html">acfutils/sysmacros.h</a>&gt;</code><br />
<code>#include &quot;vector_impl.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for vector.h:</div>
<div class="dyncontent">
<div class="center"><img src="vector_8h__incl.png" border="0" usemap="#aacfutils_2vector_8h" alt=""/></div>
<map name="aacfutils_2vector_8h" id="aacfutils_2vector_8h">
<area shape="rect" title=" " alt="" coords="279,5,406,31"/>
<area shape="rect" href="optional_8h.html" title=" " alt="" coords="273,79,412,104"/>
<area shape="poly" title=" " alt="" coords="345,31,345,65,340,65,340,31"/>
<area shape="rect" href="sysmacros_8h.html" title=" " alt="" coords="288,445,392,471"/>
<area shape="poly" title=" " alt="" coords="279,26,209,38,172,48,137,62,106,80,81,103,65,130,59,164,59,312,63,341,75,361,95,377,121,395,148,408,187,420,275,441,274,446,185,425,146,413,119,400,92,382,71,365,58,343,53,313,53,163,60,128,77,99,103,76,135,58,171,43,208,33,279,21"/>
<area shape="rect" href="vector__impl_8h_source.html" title=" " alt="" coords="727,299,838,324"/>
<area shape="poly" title=" " alt="" coords="369,28,469,78,531,112,592,150,689,223,762,287,759,291,685,227,589,154,528,117,466,82,367,33"/>
<area shape="rect" href="math_8h.html" title=" " alt="" coords="459,152,527,177"/>
<area shape="poly" title=" " alt="" coords="368,102,457,144,455,148,366,106"/>
<area shape="rect" href="assert_8h.html" title=" " alt="" coords="471,299,545,324"/>
<area shape="poly" title=" " alt="" coords="412,91,447,97,482,108,514,125,541,150,550,167,554,185,552,223,540,258,525,288,520,286,535,256,546,221,549,186,545,169,537,154,511,129,480,113,446,102,412,97"/>
<area shape="rect" href="log_8h.html" title=" " alt="" coords="133,372,187,397"/>
<area shape="poly" title=" " alt="" coords="282,106,238,124,219,137,202,154,186,178,175,204,161,261,158,315,160,358,154,358,153,315,156,260,170,203,182,175,198,150,215,133,236,119,280,102"/>
<area shape="poly" title=" " alt="" coords="308,107,273,125,258,138,246,153,232,191,230,230,236,270,249,309,267,347,286,381,324,433,319,436,282,384,262,349,244,311,231,271,224,230,227,189,242,151,254,134,270,120,305,102"/>
<area shape="rect" title=" " alt="" coords="103,592,174,617"/>
<area shape="poly" title=" " alt="" coords="290,107,235,125,207,138,181,154,111,204,56,250,36,275,21,305,11,340,8,383,8,459,11,480,17,499,42,533,73,561,105,583,102,587,70,566,38,537,13,501,5,481,3,459,3,383,6,339,16,303,31,272,52,246,107,200,179,150,205,133,233,120,288,101"/>
<area shape="rect" href="geom_8h.html" title=" " alt="" coords="591,372,662,397"/>
<area shape="poly" title=" " alt="" coords="413,93,451,99,491,109,530,126,564,150,585,173,601,199,620,257,629,313,630,358,625,358,624,313,615,258,596,201,580,176,561,154,527,131,489,114,450,104,412,98"/>
<area shape="rect" title=" " alt="" coords="257,152,327,177"/>
<area shape="poly" title=" " alt="" coords="336,106,310,142,306,139,332,103"/>
<area shape="rect" title=" " alt="" coords="352,152,435,177"/>
<area shape="poly" title=" " alt="" coords="353,103,379,139,375,142,349,106"/>
<area shape="poly" title=" " alt="" coords="497,178,508,285,503,285,492,178"/>
<area shape="rect" href="math__core_8h.html" title=" " alt="" coords="373,225,475,251"/>
<area shape="poly" title=" " alt="" coords="477,179,439,217,435,213,474,175"/>
<area shape="poly" title=" " alt="" coords="497,176,528,228,572,297,608,359,603,362,567,300,523,231,492,179"/>
<area shape="poly" title=" " alt="" coords="537,296,560,297,569,303,572,312,566,323,551,327,550,322,562,319,567,311,565,306,559,302,537,301"/>
<area shape="rect" title=" " alt="" coords="541,665,611,691"/>
<area shape="poly" title=" " alt="" coords="513,324,552,518,575,651,569,652,547,519,508,325"/>
<area shape="poly" title=" " alt="" coords="471,323,202,378,200,372,470,318"/>
<area shape="poly" title=" " alt="" coords="496,326,366,438,362,434,493,322"/>
<area shape="rect" title=" " alt="" coords="43,445,117,471"/>
<area shape="poly" title=" " alt="" coords="149,399,105,438,101,434,145,395"/>
<area shape="rect" title=" " alt="" coords="142,445,263,471"/>
<area shape="poly" title=" " alt="" coords="169,396,191,432,187,435,165,399"/>
<area shape="poly" title=" " alt="" coords="188,394,299,438,297,443,186,399"/>
<area shape="rect" href="types_8h_source.html" title=" " alt="" coords="467,519,538,544"/>
<area shape="poly" title=" " alt="" coords="367,468,465,511,462,515,365,473"/>
<area shape="poly" title=" " alt="" coords="511,543,566,652,562,654,506,546"/>
<area shape="poly" title=" " alt="" coords="468,542,188,596,187,591,467,537"/>
<area shape="rect" title=" " alt="" coords="417,592,487,617"/>
<area shape="poly" title=" " alt="" coords="496,546,470,582,466,579,492,543"/>
<area shape="rect" href="core_8h.html" title=" " alt="" coords="330,592,393,617"/>
<area shape="poly" title=" " alt="" coords="481,546,398,588,395,583,479,542"/>
<area shape="poly" title=" " alt="" coords="394,614,529,659,528,664,392,619"/>
<area shape="rect" href="libconfig_8h_source.html" title=" " alt="" coords="316,665,407,691"/>
<area shape="poly" title=" " alt="" coords="364,618,364,652,359,652,359,618"/>
<area shape="poly" title=" " alt="" coords="440,223,478,186,482,190,444,227"/>
<area shape="poly" title=" " alt="" coords="439,249,485,287,482,292,436,253"/>
<area shape="poly" title=" " alt="" coords="427,251,432,383,432,460,427,495,414,529,382,583,377,580,409,527,422,494,427,459,427,383,422,251"/>
<area shape="poly" title=" " alt="" coords="626,373,613,340,591,300,552,239,515,189,519,186,557,236,596,297,618,337,631,371"/>
<area shape="poly" title=" " alt="" coords="628,398,619,490,597,618,587,653,582,651,592,617,614,489,623,397"/>
<area shape="poly" title=" " alt="" coords="592,397,400,445,398,440,590,392"/>
<area shape="poly" title=" " alt="" coords="619,400,523,510,519,507,614,396"/>
<area shape="poly" title=" " alt="" coords="779,325,757,381,748,418,744,457,744,533,741,556,732,578,718,597,701,614,662,642,622,662,620,658,659,638,698,610,714,594,727,575,736,555,739,532,739,457,743,417,752,380,774,323"/>
<area shape="poly" title=" " alt="" coords="820,296,850,297,860,302,865,311,862,319,855,324,834,327,833,322,853,319,858,315,859,311,857,306,848,302,820,301"/>
</map>
</div>
</div>
<p><a href="vector_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1afc2a5fdc9e1f558677a7ff0af9974a" id="r_a1afc2a5fdc9e1f558677a7ff0af9974a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a1afc2a5fdc9e1f558677a7ff0af9974a">vector_create</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:a1afc2a5fdc9e1f558677a7ff0af9974a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <code><a class="el" href="structvector__t.html">vector_t</a></code> to a blank state, with zero starting capacity.  <br /></td></tr>
<tr class="separator:a1afc2a5fdc9e1f558677a7ff0af9974a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad799b5e05cd9fff2f51f39e06db8db0c" id="r_ad799b5e05cd9fff2f51f39e06db8db0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#ad799b5e05cd9fff2f51f39e06db8db0c">vector_create_cap</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), size_t cap_hint)</td></tr>
<tr class="memdesc:ad799b5e05cd9fff2f51f39e06db8db0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a new <code><a class="el" href="structvector__t.html">vector_t</a></code> with a capacity hint.  <br /></td></tr>
<tr class="separator:ad799b5e05cd9fff2f51f39e06db8db0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb082e450adaeb7a4a1b9dac4da397" id="r_af1cb082e450adaeb7a4a1b9dac4da397"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#af1cb082e450adaeb7a4a1b9dac4da397">vector_destroy</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:af1cb082e450adaeb7a4a1b9dac4da397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a vector previously created using <a class="el" href="vector_8h.html#a1afc2a5fdc9e1f558677a7ff0af9974a" title="Initializes a new vector_t to a blank state, with zero starting capacity.">vector_create()</a>.  <br /></td></tr>
<tr class="separator:af1cb082e450adaeb7a4a1b9dac4da397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a15438c1e3d795e728afb93b14245b1" id="r_a1a15438c1e3d795e728afb93b14245b1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a1a15438c1e3d795e728afb93b14245b1">vector_len</a> (const <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:a1a15438c1e3d795e728afb93b14245b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current number of elements contained inside the vector.  <br /></td></tr>
<tr class="separator:a1a15438c1e3d795e728afb93b14245b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4d243bfe3556090a71484381fa6384" id="r_abe4d243bfe3556090a71484381fa6384"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#abe4d243bfe3556090a71484381fa6384">vector_get</a> (const <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), size_t index)</td></tr>
<tr class="memdesc:abe4d243bfe3556090a71484381fa6384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves elements within the vector.  <br /></td></tr>
<tr class="separator:abe4d243bfe3556090a71484381fa6384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b82c6c492185e16c3e741ce7eaaf1b" id="r_ad8b82c6c492185e16c3e741ce7eaaf1b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#ad8b82c6c492185e16c3e741ce7eaaf1b">vector_head</a> (const <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:ad8b82c6c492185e16c3e741ce7eaaf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the element at the head of the vector, if any.  <br /></td></tr>
<tr class="separator:ad8b82c6c492185e16c3e741ce7eaaf1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5a2f97fe5b51f4acb51b9a6fb7fc45" id="r_a8c5a2f97fe5b51f4acb51b9a6fb7fc45"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a8c5a2f97fe5b51f4acb51b9a6fb7fc45">vector_tail</a> (const <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:a8c5a2f97fe5b51f4acb51b9a6fb7fc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the element at the tail of the vector, if any.  <br /></td></tr>
<tr class="separator:a8c5a2f97fe5b51f4acb51b9a6fb7fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac677fc04a8e639256c93632c6148ca54" id="r_ac677fc04a8e639256c93632c6148ca54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="optional_8h.html#a148e4316703b359faa171e06869cecbd">opt_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#ac677fc04a8e639256c93632c6148ca54">vector_find</a> (const <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), const void *item)</td></tr>
<tr class="memdesc:ac677fc04a8e639256c93632c6148ca54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locates an element in the vector by value.  <br /></td></tr>
<tr class="separator:ac677fc04a8e639256c93632c6148ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f649050b3cf0062bb9e6373c589c8da" id="r_a3f649050b3cf0062bb9e6373c589c8da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a3f649050b3cf0062bb9e6373c589c8da">vector_insert</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), void *elem, size_t index)</td></tr>
<tr class="memdesc:a3f649050b3cf0062bb9e6373c589c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element into the vector at a given index.  <br /></td></tr>
<tr class="separator:a3f649050b3cf0062bb9e6373c589c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bda2be8d144687723da24eb413b7e1" id="r_a89bda2be8d144687723da24eb413b7e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a89bda2be8d144687723da24eb413b7e1">vector_insert_tail</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), void *elem)</td></tr>
<tr class="memdesc:a89bda2be8d144687723da24eb413b7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a new element at the tail of the vector.  <br /></td></tr>
<tr class="separator:a89bda2be8d144687723da24eb413b7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9ddf2deeb8d7165d577bb0ccc37bb8" id="r_a3d9ddf2deeb8d7165d577bb0ccc37bb8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a3d9ddf2deeb8d7165d577bb0ccc37bb8">vector_replace</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), void *new_elem, size_t index)</td></tr>
<tr class="memdesc:a3d9ddf2deeb8d7165d577bb0ccc37bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces an element in the vector in-place.  <br /></td></tr>
<tr class="separator:a3d9ddf2deeb8d7165d577bb0ccc37bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa0e247dcd21269efdb3f38ea95d4aa" id="r_a2fa0e247dcd21269efdb3f38ea95d4aa"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a2fa0e247dcd21269efdb3f38ea95d4aa">vector_remove</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), size_t index)</td></tr>
<tr class="memdesc:a2fa0e247dcd21269efdb3f38ea95d4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the vector at a given index.  <br /></td></tr>
<tr class="separator:a2fa0e247dcd21269efdb3f38ea95d4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd573b80e01fa2983151b4fe82761b5" id="r_a8dd573b80e01fa2983151b4fe82761b5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a8dd573b80e01fa2983151b4fe82761b5">vector_remove_head</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:a8dd573b80e01fa2983151b4fe82761b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the first element in a vector, if any.  <br /></td></tr>
<tr class="separator:a8dd573b80e01fa2983151b4fe82761b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28df3f4d2a2a72946ed66834754815ae" id="r_a28df3f4d2a2a72946ed66834754815ae"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a28df3f4d2a2a72946ed66834754815ae">vector_remove_tail</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:a28df3f4d2a2a72946ed66834754815ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes and returns the last element in a vector, if any.  <br /></td></tr>
<tr class="separator:a28df3f4d2a2a72946ed66834754815ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8068e14f48e53a1aad836395843d3b51" id="r_a8068e14f48e53a1aad836395843d3b51"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a8068e14f48e53a1aad836395843d3b51">vector_shrink</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:a8068e14f48e53a1aad836395843d3b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders the vector to shrink to the nearest power-of-2 capacity suitable to hold its current contents.  <br /></td></tr>
<tr class="separator:a8068e14f48e53a1aad836395843d3b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af032c2db9638782f276d28da00059c66" id="r_af032c2db9638782f276d28da00059c66"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#af032c2db9638782f276d28da00059c66">vector_cap</a> (const <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v))</td></tr>
<tr class="memdesc:af032c2db9638782f276d28da00059c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current element capacity of the vector.  <br /></td></tr>
<tr class="separator:af032c2db9638782f276d28da00059c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10334f7eeca408324aee9fd6d85218ca" id="r_a10334f7eeca408324aee9fd6d85218ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a10334f7eeca408324aee9fd6d85218ca">vector_move_all</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(src), <a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(dest))</td></tr>
<tr class="memdesc:a10334f7eeca408324aee9fd6d85218ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves all elements from the <code>src</code> vector to the <code>dest</code> vector.  <br /></td></tr>
<tr class="separator:a10334f7eeca408324aee9fd6d85218ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fac8e02588fd1292036b9ba6d5b7981" id="r_a2fac8e02588fd1292036b9ba6d5b7981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#a2fac8e02588fd1292036b9ba6d5b7981">vector_sort</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), int(*sort_func)(const void *a, const void *b))</td></tr>
<tr class="memdesc:a2fac8e02588fd1292036b9ba6d5b7981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a vector using the and a sorting predicate.  <br /></td></tr>
<tr class="separator:a2fac8e02588fd1292036b9ba6d5b7981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade2aa874295fe8b65735ef1f90b8816" id="r_aade2aa874295fe8b65735ef1f90b8816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vector_8h.html#aade2aa874295fe8b65735ef1f90b8816">vector_sort_r</a> (<a class="el" href="structvector__t.html">vector_t</a> <a class="el" href="sysmacros_8h.html#a8ad7f6eb54558a573b4dc19e1bc545e9">REQ_PTR</a>(v), int(*sort_func)(const void *a, const void *b, void *userinfo), void *userinfo)</td></tr>
<tr class="memdesc:aade2aa874295fe8b65735ef1f90b8816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a vector using the and a thread-safe sorting predicate.  <br /></td></tr>
<tr class="separator:aade2aa874295fe8b65735ef1f90b8816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements a general purpose C++-like vector for C. The vector is intended as a general-purpose holder of references to other data. It is NOT intended to hold the data itself, because the vector employs reallocation of a contiguous region to hold its buffer, which can cause stuff to move around in memory. This would cause any contained <a class="el" href="structlist__t.html">list_t</a> and avl_tree_t fields to break.</p>
<p>The vector employs automatic growth management using the plain old strategy of doubling its capacity when the previous capacity has been exceeded. So if the vector currently contains 4 elements, its capacity is 4, and attempting to insert a 5th element doubles its capacity to 8 elements. Please note that this capacity management strategy is mostly invisible to you and the vector takes care of nearly everything by itself. You can, however, inspect the vector's current capacity and instruct it to shrink, if you feel the need to reclaim space.</p>
<dl class="section see"><dt>See also</dt><dd>vector_init() </dd>
<dd>
vector_fini() </dd>
<dd>
<a class="el" href="vector_8h.html#a3f649050b3cf0062bb9e6373c589c8da" title="Inserts a new element into the vector at a given index.">vector_insert()</a> </dd>
<dd>
<a class="el" href="vector_8h.html#a2fa0e247dcd21269efdb3f38ea95d4aa" title="Removes an element from the vector at a given index.">vector_remove()</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="vector_8h_source.html">vector.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af032c2db9638782f276d28da00059c66" name="af032c2db9638782f276d28da00059c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af032c2db9638782f276d28da00059c66">&#9670;&#160;</a></span>vector_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vector_cap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current element capacity of the vector. </p>
<p>The vector automatically grows by doubling capacity whenever it needs to add more elements than current has room to hold. You should generally only be manually calling <a class="el" href="vector_8h.html#af032c2db9638782f276d28da00059c66" title="Returns the current element capacity of the vector.">vector_cap()</a> and <a class="el" href="vector_8h.html#a8068e14f48e53a1aad836395843d3b51" title="Orders the vector to shrink to the nearest power-of-2 capacity suitable to hold its current contents.">vector_shrink()</a> if you have removed a large number of elements and have determined that the small amount of memory savings are worth the reallocation. </p>

</div>
</div>
<a id="a1afc2a5fdc9e1f558677a7ff0af9974a" name="a1afc2a5fdc9e1f558677a7ff0af9974a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afc2a5fdc9e1f558677a7ff0af9974a">&#9670;&#160;</a></span>vector_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new <code><a class="el" href="structvector__t.html">vector_t</a></code> to a blank state, with zero starting capacity. </p>
<p>The vector automatically grows as you insert new elements.</p>
<dl class="section note"><dt>Note</dt><dd>You MUST dispose of a created vector by calling <a class="el" href="vector_8h.html#af1cb082e450adaeb7a4a1b9dac4da397" title="Destroys a vector previously created using vector_create().">vector_destroy()</a>. </dd></dl>

</div>
</div>
<a id="ad799b5e05cd9fff2f51f39e06db8db0c" name="ad799b5e05cd9fff2f51f39e06db8db0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad799b5e05cd9fff2f51f39e06db8db0c">&#9670;&#160;</a></span>vector_create_cap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_create_cap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cap_hint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a new <code><a class="el" href="structvector__t.html">vector_t</a></code> with a capacity hint. </p>
<p>You can use this to hint the vector ahead of time, if the number of elements which will be inserted into the vector is known. This can help prevent large numbers of reallocations, as the vector grows in response to insertions.</p>
<dl class="section note"><dt>Note</dt><dd>You MUST dispose of a created vector by calling <a class="el" href="vector_8h.html#af1cb082e450adaeb7a4a1b9dac4da397" title="Destroys a vector previously created using vector_create().">vector_destroy()</a>. </dd></dl>

</div>
</div>
<a id="af1cb082e450adaeb7a4a1b9dac4da397" name="af1cb082e450adaeb7a4a1b9dac4da397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cb082e450adaeb7a4a1b9dac4da397">&#9670;&#160;</a></span>vector_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a vector previously created using <a class="el" href="vector_8h.html#a1afc2a5fdc9e1f558677a7ff0af9974a" title="Initializes a new vector_t to a blank state, with zero starting capacity.">vector_create()</a>. </p>
<p>You MUST call this function to properly dispose of a vector and its internal buffers. You must first make sure the vector is empty of all its contents before attempting to destroy it. </p>

</div>
</div>
<a id="ac677fc04a8e639256c93632c6148ca54" name="ac677fc04a8e639256c93632c6148ca54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac677fc04a8e639256c93632c6148ca54">&#9670;&#160;</a></span>vector_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="optional_8h.html#a148e4316703b359faa171e06869cecbd">opt_size_t</a> vector_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locates an element in the vector by value. </p>
<p>Attempts to locate an element by pointer value. If the element was found, its index is returned, wrapped in a <a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME()</a> type. Otherwise, NONE is returned. </p>

</div>
</div>
<a id="abe4d243bfe3556090a71484381fa6384" name="abe4d243bfe3556090a71484381fa6384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4d243bfe3556090a71484381fa6384">&#9670;&#160;</a></span>vector_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves elements within the vector. </p>
<p>Retrieves the contents of the vector at <code>index</code>. You must NOT attempt to access an index which is beyond the vector's current length. So <code>index</code> must ALWAYS be less than the value returned by <a class="el" href="vector_8h.html#a1a15438c1e3d795e728afb93b14245b1" title="Returns the current number of elements contained inside the vector.">vector_len()</a>. </p>

</div>
</div>
<a id="ad8b82c6c492185e16c3e741ce7eaaf1b" name="ad8b82c6c492185e16c3e741ce7eaaf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b82c6c492185e16c3e741ce7eaaf1b">&#9670;&#160;</a></span>vector_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the element at the head of the vector, if any. </p>
<p>Retrieves the first element in the vector, if one is present, without removing it from the vector. If vector is empty, returns NULL instead. </p>

</div>
</div>
<a id="a3f649050b3cf0062bb9e6373c589c8da" name="a3f649050b3cf0062bb9e6373c589c8da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f649050b3cf0062bb9e6373c589c8da">&#9670;&#160;</a></span>vector_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element into the vector at a given index. </p>
<p>Any elements inside of the vector after <code>index</code> will be pushed back by 1 index. The <code>index</code> argument MUST be less-than-or-equal to <a class="el" href="vector_8h.html#a1a15438c1e3d795e728afb93b14245b1" title="Returns the current number of elements contained inside the vector.">vector_len()</a>. You can also use the more concise <a class="el" href="vector_8h.html#a89bda2be8d144687723da24eb413b7e1" title="Inserts a new element at the tail of the vector.">vector_insert_tail()</a> function to insert elements at the tail of the vector, rather than the slightly more verbose <code>vector_insert(v, new_elem, vector_len())</code>. </p>

</div>
</div>
<a id="a89bda2be8d144687723da24eb413b7e1" name="a89bda2be8d144687723da24eb413b7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bda2be8d144687723da24eb413b7e1">&#9670;&#160;</a></span>vector_insert_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_insert_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a new element at the tail of the vector. </p>
<p>This is equivalent to calling <code>vector_insert(v, new_elem, vector_len())</code>, but is a bit more concise and neater. </p>

</div>
</div>
<a id="a1a15438c1e3d795e728afb93b14245b1" name="a1a15438c1e3d795e728afb93b14245b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a15438c1e3d795e728afb93b14245b1">&#9670;&#160;</a></span>vector_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vector_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current number of elements contained inside the vector. </p>
<p>This is NOT the vector's capacity. It is the number of items you have currently inserted into the vector. Thus, this represents the highest index you can use in <a class="el" href="vector_8h.html#a3f649050b3cf0062bb9e6373c589c8da" title="Inserts a new element into the vector at a given index.">vector_insert()</a> to add new elements, and it is +1 the highest index you can retrieve using <a class="el" href="vector_8h.html#abe4d243bfe3556090a71484381fa6384" title="Retrieves elements within the vector.">vector_get()</a>. </p>

</div>
</div>
<a id="a10334f7eeca408324aee9fd6d85218ca" name="a10334f7eeca408324aee9fd6d85218ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10334f7eeca408324aee9fd6d85218ca">&#9670;&#160;</a></span>vector_move_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_move_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>dest&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves all elements from the <code>src</code> vector to the <code>dest</code> vector. </p>
<p>The <code>dest</code> vector MUST NOT contain any elements. The <code>src</code> vector is emptied after this operation and reinitialized to zero capacity. In essence, the <code>dest</code> vector "takes over" all of the elements from <code>src</code>. </p>

</div>
</div>
<a id="a2fa0e247dcd21269efdb3f38ea95d4aa" name="a2fa0e247dcd21269efdb3f38ea95d4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa0e247dcd21269efdb3f38ea95d4aa">&#9670;&#160;</a></span>vector_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an element from the vector at a given index. </p>
<p>This causes any elements behind the removed value to shift forward by one index. The previously contained element at <code>index</code> is returned from this function. The <code>index</code> argument MUST be less than the return value of <a class="el" href="vector_8h.html#a1a15438c1e3d795e728afb93b14245b1" title="Returns the current number of elements contained inside the vector.">vector_len()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The vector internal capacity doesn't automatically shrink after removing elements. If you want to force the vector to shrink its buffer, use <a class="el" href="vector_8h.html#a8068e14f48e53a1aad836395843d3b51" title="Orders the vector to shrink to the nearest power-of-2 capacity suitable to hold its current contents.">vector_shrink()</a>. </dd></dl>

</div>
</div>
<a id="a8dd573b80e01fa2983151b4fe82761b5" name="a8dd573b80e01fa2983151b4fe82761b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd573b80e01fa2983151b4fe82761b5">&#9670;&#160;</a></span>vector_remove_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_remove_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the first element in a vector, if any. </p>
<p>This behaves almost the same was as <a class="el" href="vector_8h.html#a2fa0e247dcd21269efdb3f38ea95d4aa" title="Removes an element from the vector at a given index.">vector_remove()</a> with a zero index argument, except that calling <a class="el" href="vector_8h.html#a8dd573b80e01fa2983151b4fe82761b5" title="Removes and returns the first element in a vector, if any.">vector_remove_head()</a> on an empty vector is a valid operation. The element previously contained at index 0 is returned, or if the vector was empty, returns NULL. Any elements following the first element are shifted forward by one index.</p>
<dl class="section note"><dt>Note</dt><dd>The most efficient way to remove all elements from a vector is to employ a loop of <a class="el" href="vector_8h.html#a28df3f4d2a2a72946ed66834754815ae" title="Removes and returns the last element in a vector, if any.">vector_remove_tail()</a> instead of <a class="el" href="vector_8h.html#a8dd573b80e01fa2983151b4fe82761b5" title="Removes and returns the first element in a vector, if any.">vector_remove_head()</a>, because the tail-removing version avoids any calls to <code>memmove()</code> to shift elements around. Simply call <a class="el" href="vector_8h.html#a28df3f4d2a2a72946ed66834754815ae" title="Removes and returns the last element in a vector, if any.">vector_remove_tail()</a> until the function returns NULL. </dd></dl>

</div>
</div>
<a id="a28df3f4d2a2a72946ed66834754815ae" name="a28df3f4d2a2a72946ed66834754815ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28df3f4d2a2a72946ed66834754815ae">&#9670;&#160;</a></span>vector_remove_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_remove_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes and returns the last element in a vector, if any. </p>
<p>This behaves almost the same was as <a class="el" href="vector_8h.html#a2fa0e247dcd21269efdb3f38ea95d4aa" title="Removes an element from the vector at a given index.">vector_remove()</a> with a <code><a class="el" href="vector_8h.html#a1a15438c1e3d795e728afb93b14245b1" title="Returns the current number of elements contained inside the vector.">vector_len()</a>-1</code> index argument, except that calling <a class="el" href="vector_8h.html#a28df3f4d2a2a72946ed66834754815ae" title="Removes and returns the last element in a vector, if any.">vector_remove_tail()</a> on an empty vector is a valid operation. The element previously contained at the end of the vector is returned, or if the vector was empty, returns NULL.</p>
<dl class="section note"><dt>Note</dt><dd>The most efficient way to remove all elements from a vector is to employ a loop of <a class="el" href="vector_8h.html#a28df3f4d2a2a72946ed66834754815ae" title="Removes and returns the last element in a vector, if any.">vector_remove_tail()</a> instead of <a class="el" href="vector_8h.html#a8dd573b80e01fa2983151b4fe82761b5" title="Removes and returns the first element in a vector, if any.">vector_remove_head()</a>, because the tail-removing version avoids any calls to <code>memmove()</code> to shift elements around. Simply call <a class="el" href="vector_8h.html#a28df3f4d2a2a72946ed66834754815ae" title="Removes and returns the last element in a vector, if any.">vector_remove_tail()</a> until the function returns NULL. </dd></dl>

</div>
</div>
<a id="a3d9ddf2deeb8d7165d577bb0ccc37bb8" name="a3d9ddf2deeb8d7165d577bb0ccc37bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9ddf2deeb8d7165d577bb0ccc37bb8">&#9670;&#160;</a></span>vector_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>new_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces an element in the vector in-place. </p>
<p>This allows you to substitute elements in the vector without first inserting the new and then removing the old value, and thus avoiding any resizing of the vector. The <code>index</code> argument MUST be less than the return value of <a class="el" href="vector_8h.html#a1a15438c1e3d795e728afb93b14245b1" title="Returns the current number of elements contained inside the vector.">vector_len()</a>.</p>
<p>This function returns the previous element contained at <code>index</code>. </p>

</div>
</div>
<a id="a8068e14f48e53a1aad836395843d3b51" name="a8068e14f48e53a1aad836395843d3b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8068e14f48e53a1aad836395843d3b51">&#9670;&#160;</a></span>vector_shrink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vector_shrink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orders the vector to shrink to the nearest power-of-2 capacity suitable to hold its current contents. </p>
<p>You can use this function to force a vector to release excess memory after removing a large number of elements from it. It is generally NOT required to call this removing items from the vector. You should only attempt to shrink vectors if you have determined that doing so will provide significant memory savings by reducing the vector's memory footprint.</p>
<p>Returns the new capacity of the vector after the shrink. </p>

</div>
</div>
<a id="a2fac8e02588fd1292036b9ba6d5b7981" name="a2fac8e02588fd1292036b9ba6d5b7981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fac8e02588fd1292036b9ba6d5b7981">&#9670;&#160;</a></span>vector_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *a, const void *b)&#160;</td>
          <td class="paramname"><em>sort_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a vector using the and a sorting predicate. </p>
<p>The <code>sort_func</code> function will receive the values of elements in the vector for comparison purposes, and return one of the following 3 values:</p><ul>
<li><code>&lt;0</code> if <code>a &gt; b</code> (elements ordered descending)</li>
<li><code>0</code> if <code>a = b</code></li>
<li><code>&gt;0</code> if <code>a &lt; b</code> (elements ordered ascending) For example, the return value of the <code>strcmp()</code> function follows this same pattern, and if used for values in <a class="el" href="structvector__t.html">vector_t</a>, would result in alphabetically sorting the vector's contents. </li>
</ul>

</div>
</div>
<a id="aade2aa874295fe8b65735ef1f90b8816" name="aade2aa874295fe8b65735ef1f90b8816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade2aa874295fe8b65735ef1f90b8816">&#9670;&#160;</a></span>vector_sort_r()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vector_sort_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *a, const void *b, void *userinfo)&#160;</td>
          <td class="paramname"><em>sort_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts a vector using the and a thread-safe sorting predicate. </p>
<p>This is similar to <a class="el" href="vector_8h.html#a2fac8e02588fd1292036b9ba6d5b7981" title="Sorts a vector using the and a sorting predicate.">vector_sort()</a>, but this function and the sorting predicate take an additional <code>userinfo</code> argument, which can be any arbitrary data you want. You can use this to construct a thread-safe sorting predicate, or simply to pass additional information to the sorting predicate.</p>
<dl class="section note"><dt>Note</dt><dd>This does not imply any kind of thread-safety of <a class="el" href="structvector__t.html">vector_t</a> itself. It is generally NOT safe to access a <a class="el" href="structvector__t.html">vector_t</a> from multiple threads, unless external locking is employed. </dd></dl>

</div>
</div>
<a id="a8c5a2f97fe5b51f4acb51b9a6fb7fc45" name="a8c5a2f97fe5b51f4acb51b9a6fb7fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5a2f97fe5b51f4acb51b9a6fb7fc45">&#9670;&#160;</a></span>vector_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vector_tail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvector__t.html">vector_t</a> &#160;</td>
          <td class="paramname"><em>REQ_PTR</em>v</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the element at the tail of the vector, if any. </p>
<p>Retrieves the last element in the vector, if one is present, without removing it from the vector. If vector is empty, returns NULL instead. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
