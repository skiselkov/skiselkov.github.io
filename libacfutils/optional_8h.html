<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libacfutils: acfutils/optional.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libacfutils
   </div>
   <div id="projectbrief">A general purpose library of utility functions designed to make it easier to develop addons for the X-Plane flight simulator.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2f18166f86af4fcbeaddefb60d5355e9.html">acfutils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">optional.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="math_8h_source.html">math.h</a>&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;<a class="el" href="assert_8h_source.html">assert.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log_8h_source.html">log.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geom_8h_source.html">geom.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sysmacros_8h_source.html">sysmacros.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for optional.h:</div>
<div class="dyncontent">
<div class="center"><img src="optional_8h__incl.png" border="0" usemap="#aacfutils_2optional_8h" alt=""/></div>
<map name="aacfutils_2optional_8h" id="aacfutils_2optional_8h">
<area shape="rect" title=" " alt="" coords="435,5,573,32"/>
<area shape="rect" href="math_8h.html" title=" " alt="" coords="335,80,403,107"/>
<area shape="rect" href="assert_8h.html" title=" " alt="" coords="264,229,339,256"/>
<area shape="rect" href="log_8h.html" title=" " alt="" coords="175,304,230,331"/>
<area shape="rect" href="sysmacros_8h.html" title=" " alt="" coords="389,379,493,405"/>
<area shape="rect" title=" " alt="" coords="486,528,557,555"/>
<area shape="rect" href="geom_8h.html" title=" " alt="" coords="494,229,565,256"/>
<area shape="rect" title=" " alt="" coords="682,80,753,107"/>
<area shape="rect" title=" " alt="" coords="777,80,860,107"/>
<area shape="rect" href="math__core_8h.html" title=" " alt="" coords="250,155,353,181"/>
<area shape="rect" title=" " alt="" coords="357,603,427,629"/>
<area shape="rect" title=" " alt="" coords="43,379,117,405"/>
<area shape="rect" title=" " alt="" coords="142,379,263,405"/>
<area shape="rect" href="types_8h_source.html" title=" " alt="" coords="409,453,479,480"/>
<area shape="rect" title=" " alt="" coords="339,528,410,555"/>
<area shape="rect" href="core_8h.html" title=" " alt="" coords="201,528,263,555"/>
<area shape="rect" href="libconfig_8h_source.html" title=" " alt="" coords="187,603,277,629"/>
</map>
</div>
</div>
<p><a href="optional_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__int8__t.html">opt_int8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping an <code>int8_t</code> value.  <a href="structopt__int8__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__uint8__t.html">opt_uint8_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a <code>uint8_t</code> value.  <a href="structopt__uint8__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__int16__t.html">opt_int16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping an <code>int16_t</code> value.  <a href="structopt__int16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__uint16__t.html">opt_uint16_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a <code>uint16_t</code> value.  <a href="structopt__uint16__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__int32__t.html">opt_int32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping an <code>int32_t</code> value.  <a href="structopt__int32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__uint32__t.html">opt_uint32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a <code>uint32_t</code> value.  <a href="structopt__uint32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__int64__t.html">opt_int64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping an <code>int64_t</code> value.  <a href="structopt__int64__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__uint64__t.html">opt_uint64_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a <code>uint64_t</code> value.  <a href="structopt__uint64__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__float.html">opt_float</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NAN <code>float</code> value.  <a href="structopt__float.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__double.html">opt_double</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NAN <code>double</code> value.  <a href="structopt__double.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__str.html">opt_str</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code>char *</code> value.  <a href="structopt__str.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__str__const.html">opt_str_const</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code>char const *</code> value.  <a href="structopt__str__const.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__vect2__t.html">opt_vect2_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structvect2__t.html">vect2_t</a></code> value.  <a href="structopt__vect2__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__vect3__t.html">opt_vect3_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structvect3__t.html">vect3_t</a></code> value.  <a href="structopt__vect3__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__vect3l__t.html">opt_vect3l_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structvect3l__t.html">vect3l_t</a></code> value.  <a href="structopt__vect3l__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__geo__pos2__t.html">opt_geo_pos2_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structgeo__pos2__t.html">geo_pos2_t</a></code> value.  <a href="structopt__geo__pos2__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__geo__pos3__t.html">opt_geo_pos3_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structgeo__pos3__t.html">geo_pos3_t</a></code> value.  <a href="structopt__geo__pos3__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__geo__pos2__32__t.html">opt_geo_pos2_32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structgeo__pos2__32__t.html">geo_pos2_32_t</a></code> value.  <a href="structopt__geo__pos2__32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopt__geo__pos3__32__t.html">opt_geo_pos3_32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a non-NULL <code><a class="el" href="structgeo__pos3__32__t.html">geo_pos3_32_t</a></code> value.  <a href="structopt__geo__pos3__32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a308278970253212c8e9f8c0ae317b96a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a">IMPL_OPTIONAL_EXPLICIT</a>(type_name,  c_type)</td></tr>
<tr class="memdesc:a308278970253212c8e9f8c0ae317b96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a custom optional type with explicit NONE encoding.  <a href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a">More...</a><br /></td></tr>
<tr class="separator:a308278970253212c8e9f8c0ae317b96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784e18ac9e8950db47089383372b2e93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a784e18ac9e8950db47089383372b2e93">IMPL_OPTIONAL_IMPLICIT</a>(type_name,  c_type,  none_value,  none_check)</td></tr>
<tr class="memdesc:a784e18ac9e8950db47089383372b2e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a custom optional type with implicit NONE encoding.  <a href="optional_8h.html#a784e18ac9e8950db47089383372b2e93">More...</a><br /></td></tr>
<tr class="separator:a784e18ac9e8950db47089383372b2e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095de7c69ad75a230d72f24f5eff5809"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a095de7c69ad75a230d72f24f5eff5809">IMPL_OPTIONAL_ALIAS</a>(orig_type_name,  alias_type_name,  alias_c_type)</td></tr>
<tr class="memdesc:a095de7c69ad75a230d72f24f5eff5809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a type alias for an existing optional type.  <a href="optional_8h.html#a095de7c69ad75a230d72f24f5eff5809">More...</a><br /></td></tr>
<tr class="separator:a095de7c69ad75a230d72f24f5eff5809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783fdd25c33e6bc7f19275548404e578"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a783fdd25c33e6bc7f19275548404e578">OPTIONAL_TYPE_LIST_ADD</a>(type_name,  c_type,  op_name)&#160;&#160;&#160;	c_type: op_name ## type_name</td></tr>
<tr class="memdesc:a783fdd25c33e6bc7f19275548404e578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new entry to the definition of the <a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f" title="Overridable list of custom optional types provided by your code.">OPTIONAL_TYPE_LIST()</a> macro.  <a href="optional_8h.html#a783fdd25c33e6bc7f19275548404e578">More...</a><br /></td></tr>
<tr class="separator:a783fdd25c33e6bc7f19275548404e578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bc079f415a97870a88de442562210f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f">OPTIONAL_TYPE_LIST</a>(op_name)&#160;&#160;&#160;    default: _unknown_optional_type_you_need_to_include_your_custom_optional_h_</td></tr>
<tr class="memdesc:af1bc079f415a97870a88de442562210f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overridable list of custom optional types provided by your code.  <a href="optional_8h.html#af1bc079f415a97870a88de442562210f">More...</a><br /></td></tr>
<tr class="separator:af1bc079f415a97870a88de442562210f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37ae435f25f46c67993270d88bc219d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d">SOME</a>(expr)&#160;&#160;&#160;OPTIONAL_TYPE_SELECTOR(opt_some_, expr)(expr)</td></tr>
<tr class="memdesc:ad37ae435f25f46c67993270d88bc219d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new optional value in the SOME state.  <a href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d">More...</a><br /></td></tr>
<tr class="separator:ad37ae435f25f46c67993270d88bc219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1dd117c8e0f7c9a98acd48235cd2f8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a8a1dd117c8e0f7c9a98acd48235cd2f8">NONE</a>(type_name)&#160;&#160;&#160;opt_none_ ## type_name()</td></tr>
<tr class="memdesc:a8a1dd117c8e0f7c9a98acd48235cd2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new optional value in the NONE state.  <a href="optional_8h.html#a8a1dd117c8e0f7c9a98acd48235cd2f8">More...</a><br /></td></tr>
<tr class="separator:a8a1dd117c8e0f7c9a98acd48235cd2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eb6100d3f12d967c23fd51eaa80d37"><td class="memItemLeft" align="right" valign="top"><a id="a67eb6100d3f12d967c23fd51eaa80d37"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a67eb6100d3f12d967c23fd51eaa80d37">IS_SOME</a>(opt)&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_is_some_, (opt).value)(opt)</td></tr>
<tr class="memdesc:a67eb6100d3f12d967c23fd51eaa80d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the optional is in the SOME state. <br /></td></tr>
<tr class="separator:a67eb6100d3f12d967c23fd51eaa80d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cab986d1f0da7498c0956df0e6c2536"><td class="memItemLeft" align="right" valign="top"><a id="a1cab986d1f0da7498c0956df0e6c2536"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536">IS_NONE</a>(x)&#160;&#160;&#160;(!<a class="el" href="optional_8h.html#a67eb6100d3f12d967c23fd51eaa80d37">IS_SOME</a>(x))</td></tr>
<tr class="memdesc:a1cab986d1f0da7498c0956df0e6c2536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the optional is in the NONE state. <br /></td></tr>
<tr class="separator:a1cab986d1f0da7498c0956df0e6c2536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2138afa1ae8fb5f0e9127f90098469"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a>(opt,  out_value)&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_match_, (opt).value)((opt), (out_value))</td></tr>
<tr class="memdesc:ace2138afa1ae8fb5f0e9127f90098469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value embedded in the optional and returns the <code>optional_state_t</code> enum corresponding to the state.  <a href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">More...</a><br /></td></tr>
<tr class="separator:ace2138afa1ae8fb5f0e9127f90098469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fa7456dfc3fb1e8896b95c3aa80bf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ab9fa7456dfc3fb1e8896b95c3aa80bf2">MATCH_AS_REF</a>(opt,  out_value_p)</td></tr>
<tr class="memdesc:ab9fa7456dfc3fb1e8896b95c3aa80bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an immutable reference to the value embedded in the optional and returns the <code>optional_state_t</code> enum corresponding to the state.  <a href="optional_8h.html#ab9fa7456dfc3fb1e8896b95c3aa80bf2">More...</a><br /></td></tr>
<tr class="separator:ab9fa7456dfc3fb1e8896b95c3aa80bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad597bc0d9a06c841ff83207760bdee87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ad597bc0d9a06c841ff83207760bdee87">MATCH_AS_MUT</a>(opt,  out_value_p)</td></tr>
<tr class="memdesc:ad597bc0d9a06c841ff83207760bdee87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a reference to the value embedded in the optional and returns the <code>optional_state_t</code> enum corresponding to the state.  <a href="optional_8h.html#ad597bc0d9a06c841ff83207760bdee87">More...</a><br /></td></tr>
<tr class="separator:ad597bc0d9a06c841ff83207760bdee87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d5589a8cfccfee83d6e1688eb9769"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">UNWRAP</a>(opt)</td></tr>
<tr class="memdesc:a8a7d5589a8cfccfee83d6e1688eb9769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value of the optional unconditionally.  <a href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">More...</a><br /></td></tr>
<tr class="separator:a8a7d5589a8cfccfee83d6e1688eb9769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3349fe30b9b3402f8be17056d4096a8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ac3349fe30b9b3402f8be17056d4096a8">UNWRAP_AS_REF</a>(opt)</td></tr>
<tr class="memdesc:ac3349fe30b9b3402f8be17056d4096a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an immutable reference to the value of the optional unconditionally.  <a href="optional_8h.html#ac3349fe30b9b3402f8be17056d4096a8">More...</a><br /></td></tr>
<tr class="separator:ac3349fe30b9b3402f8be17056d4096a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01ed771f70d85ff89606a591b79d2aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ae01ed771f70d85ff89606a591b79d2aa">UNWRAP_AS_MUT</a>(opt)</td></tr>
<tr class="memdesc:ae01ed771f70d85ff89606a591b79d2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts a mutable reference to the value of the optional unconditionally.  <a href="optional_8h.html#ae01ed771f70d85ff89606a591b79d2aa">More...</a><br /></td></tr>
<tr class="separator:ae01ed771f70d85ff89606a591b79d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9cffa8e039ff076b435e897846a83d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d">UNWRAP_OR</a>(opt,  dfl_value)&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_unwrap_or_, (opt).value)((opt), (dfl_value))</td></tr>
<tr class="memdesc:a2f9cffa8e039ff076b435e897846a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value of the optional, or evaluates to a fallback value.  <a href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d">More...</a><br /></td></tr>
<tr class="separator:a2f9cffa8e039ff076b435e897846a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdab34dccc16a52317b37db053d1db9e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e">UNWRAP_OR_ELSE</a>(opt,  dfl_func,  dfl_arg)</td></tr>
<tr class="memdesc:abdab34dccc16a52317b37db053d1db9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the value of the optional, or yields a fallback value with lazy evaluation.  <a href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e">More...</a><br /></td></tr>
<tr class="separator:abdab34dccc16a52317b37db053d1db9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed10e38616c95b04336c8af536addc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a4ed10e38616c95b04336c8af536addc2">UNWRAP_OR_RET</a>(opt, ...)</td></tr>
<tr class="memdesc:a4ed10e38616c95b04336c8af536addc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps a SOME value, or in case of a NONE value, returns from the current function.  <a href="optional_8h.html#a4ed10e38616c95b04336c8af536addc2">More...</a><br /></td></tr>
<tr class="separator:a4ed10e38616c95b04336c8af536addc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7b9cfb51a5a99a436e2b7931bda182"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a0b7b9cfb51a5a99a436e2b7931bda182">UNWRAP_OR_GOTO</a>(opt,  label)</td></tr>
<tr class="memdesc:a0b7b9cfb51a5a99a436e2b7931bda182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps a SOME value, or in case of a NONE value, goes to the label.  <a href="optional_8h.html#a0b7b9cfb51a5a99a436e2b7931bda182">More...</a><br /></td></tr>
<tr class="separator:a0b7b9cfb51a5a99a436e2b7931bda182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c9931829ced65af643eee46c5f89d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a35c9931829ced65af643eee46c5f89d3">UNWRAP_OR_BREAK</a>(opt)</td></tr>
<tr class="memdesc:a35c9931829ced65af643eee46c5f89d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps a SOME value, or in case of a NONE value, breaks out of the current loop or switch case (invokes the <code>break</code> keyword).  <a href="optional_8h.html#a35c9931829ced65af643eee46c5f89d3">More...</a><br /></td></tr>
<tr class="separator:a35c9931829ced65af643eee46c5f89d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec726970abcfff30b1393958aa3768c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a1ec726970abcfff30b1393958aa3768c">UNWRAP_OR_CONTINUE</a>(opt)</td></tr>
<tr class="memdesc:a1ec726970abcfff30b1393958aa3768c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unwraps a SOME value, or in case of a NONE value, restarts the current loop iteration (invokes the <code>continue</code> keyword).  <a href="optional_8h.html#a1ec726970abcfff30b1393958aa3768c">More...</a><br /></td></tr>
<tr class="separator:a1ec726970abcfff30b1393958aa3768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65621263872982e2ecf95bb2c190810"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ab65621263872982e2ecf95bb2c190810">OPT_OR</a>(a,  b)&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_or_, (a).value)((a), (b))</td></tr>
<tr class="memdesc:ab65621263872982e2ecf95bb2c190810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects between two optional values based on whether the first optional is in the SOME state.  <a href="optional_8h.html#ab65621263872982e2ecf95bb2c190810">More...</a><br /></td></tr>
<tr class="separator:ab65621263872982e2ecf95bb2c190810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2271bdc73a0d537f55c0beefbd09b8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8">OPT_OR_ELSE</a>(a,  func_b,  arg_b)&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_or_else_, (a).value)((a), (func_b), (arg_b))</td></tr>
<tr class="memdesc:a9a2271bdc73a0d537f55c0beefbd09b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects between two optional values based on whether the first optional is in the SOME state. Provides lazy evaluation.  <a href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8">More...</a><br /></td></tr>
<tr class="separator:a9a2271bdc73a0d537f55c0beefbd09b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50612b5c0dc6f77d51269f51e935785"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785">IF_LET</a>(vartype,  varname,  opt)</td></tr>
<tr class="memdesc:af50612b5c0dc6f77d51269f51e935785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows constructing Rust-like if-let statements in C.  <a href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785">More...</a><br /></td></tr>
<tr class="separator:af50612b5c0dc6f77d51269f51e935785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ec60060bf83079070ef896e6a46a9c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a20ec60060bf83079070ef896e6a46a9c">IF_LET_AS_REF</a>(vartype,  varname,  opt)</td></tr>
<tr class="memdesc:a20ec60060bf83079070ef896e6a46a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785" title="Allows constructing Rust-like if-let statements in C.">IF_LET()</a> macro, but returns reference to the value.  <a href="optional_8h.html#a20ec60060bf83079070ef896e6a46a9c">More...</a><br /></td></tr>
<tr class="separator:a20ec60060bf83079070ef896e6a46a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b197c4eb4243b3a74bac0736911fc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ad2b197c4eb4243b3a74bac0736911fc5">OPT_INTO</a>(value)&#160;&#160;&#160;OPTIONAL_TYPE_SELECTOR(opt_into_, (value))(value)</td></tr>
<tr class="memdesc:ad2b197c4eb4243b3a74bac0736911fc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows wrapping an implicitly representable value into a suitable optional.  <a href="optional_8h.html#ad2b197c4eb4243b3a74bac0736911fc5">More...</a><br /></td></tr>
<tr class="separator:ad2b197c4eb4243b3a74bac0736911fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a148e4316703b359faa171e06869cecbd"><td class="memItemLeft" align="right" valign="top"><a id="a148e4316703b359faa171e06869cecbd"></a>
typedef <a class="el" href="structopt__uint64__t.html">opt_uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a148e4316703b359faa171e06869cecbd">opt_size_t</a></td></tr>
<tr class="memdesc:a148e4316703b359faa171e06869cecbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional type for wrapping a <code>size_t</code> value. <br /></td></tr>
<tr class="separator:a148e4316703b359faa171e06869cecbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ecf6b6e49cc27531fe042eb97f979"><td class="memItemLeft" align="right" valign="top"><a id="a939ecf6b6e49cc27531fe042eb97f979"></a>
typedef <a class="el" href="structopt__int8__t.html">opt_int8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a939ecf6b6e49cc27531fe042eb97f979">opt_i8</a></td></tr>
<tr class="memdesc:a939ecf6b6e49cc27531fe042eb97f979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__int8__t.html" title="An optional type for wrapping an int8_t value.">opt_int8_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:a939ecf6b6e49cc27531fe042eb97f979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad183ec0bf19896b17bb80f5cbac7f043"><td class="memItemLeft" align="right" valign="top"><a id="ad183ec0bf19896b17bb80f5cbac7f043"></a>
typedef <a class="el" href="structopt__uint8__t.html">opt_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ad183ec0bf19896b17bb80f5cbac7f043">opt_u8</a></td></tr>
<tr class="memdesc:ad183ec0bf19896b17bb80f5cbac7f043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__uint8__t.html" title="An optional type for wrapping a uint8_t value.">opt_uint8_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:ad183ec0bf19896b17bb80f5cbac7f043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cedb1b96c9646f26da0cc0a02e24c9"><td class="memItemLeft" align="right" valign="top"><a id="aa3cedb1b96c9646f26da0cc0a02e24c9"></a>
typedef <a class="el" href="structopt__int16__t.html">opt_int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#aa3cedb1b96c9646f26da0cc0a02e24c9">opt_i16</a></td></tr>
<tr class="memdesc:aa3cedb1b96c9646f26da0cc0a02e24c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__int16__t.html" title="An optional type for wrapping an int16_t value.">opt_int16_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:aa3cedb1b96c9646f26da0cc0a02e24c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa86371541fc193318f70139543e1aa2"><td class="memItemLeft" align="right" valign="top"><a id="afa86371541fc193318f70139543e1aa2"></a>
typedef <a class="el" href="structopt__uint16__t.html">opt_uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#afa86371541fc193318f70139543e1aa2">opt_u16</a></td></tr>
<tr class="memdesc:afa86371541fc193318f70139543e1aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__uint16__t.html" title="An optional type for wrapping a uint16_t value.">opt_uint16_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:afa86371541fc193318f70139543e1aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58bb9d2f4e966598a2035a4cc0979574"><td class="memItemLeft" align="right" valign="top"><a id="a58bb9d2f4e966598a2035a4cc0979574"></a>
typedef <a class="el" href="structopt__int32__t.html">opt_int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a58bb9d2f4e966598a2035a4cc0979574">opt_i32</a></td></tr>
<tr class="memdesc:a58bb9d2f4e966598a2035a4cc0979574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__int32__t.html" title="An optional type for wrapping an int32_t value.">opt_int32_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:a58bb9d2f4e966598a2035a4cc0979574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5e818472ac3798255864399436409"><td class="memItemLeft" align="right" valign="top"><a id="a2da5e818472ac3798255864399436409"></a>
typedef <a class="el" href="structopt__uint32__t.html">opt_uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a2da5e818472ac3798255864399436409">opt_u32</a></td></tr>
<tr class="memdesc:a2da5e818472ac3798255864399436409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__uint32__t.html" title="An optional type for wrapping a uint32_t value.">opt_uint32_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:a2da5e818472ac3798255864399436409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf856309d66cc728bc6301aaed6105b"><td class="memItemLeft" align="right" valign="top"><a id="aadf856309d66cc728bc6301aaed6105b"></a>
typedef <a class="el" href="structopt__int64__t.html">opt_int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#aadf856309d66cc728bc6301aaed6105b">opt_i64</a></td></tr>
<tr class="memdesc:aadf856309d66cc728bc6301aaed6105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__int64__t.html" title="An optional type for wrapping an int64_t value.">opt_int64_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:aadf856309d66cc728bc6301aaed6105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983e54c1bf0670e5f518408e786a44c7"><td class="memItemLeft" align="right" valign="top"><a id="a983e54c1bf0670e5f518408e786a44c7"></a>
typedef <a class="el" href="structopt__uint64__t.html">opt_uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#a983e54c1bf0670e5f518408e786a44c7">opt_u64</a></td></tr>
<tr class="memdesc:a983e54c1bf0670e5f518408e786a44c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__uint64__t.html" title="An optional type for wrapping a uint64_t value.">opt_uint64_t</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:a983e54c1bf0670e5f518408e786a44c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9d6a40124de05b87228c94a938eaf2"><td class="memItemLeft" align="right" valign="top"><a id="abf9d6a40124de05b87228c94a938eaf2"></a>
typedef <a class="el" href="optional_8h.html#a148e4316703b359faa171e06869cecbd">opt_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#abf9d6a40124de05b87228c94a938eaf2">opt_usize</a></td></tr>
<tr class="memdesc:abf9d6a40124de05b87228c94a938eaf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for opt_size_t available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:abf9d6a40124de05b87228c94a938eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b9642c4973cd5a20870aa3fd0a1efc"><td class="memItemLeft" align="right" valign="top"><a id="ac0b9642c4973cd5a20870aa3fd0a1efc"></a>
typedef <a class="el" href="structopt__float.html">opt_float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#ac0b9642c4973cd5a20870aa3fd0a1efc">opt_f32</a></td></tr>
<tr class="memdesc:ac0b9642c4973cd5a20870aa3fd0a1efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__float.html" title="An optional type for wrapping a non-NAN float value.">opt_float</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:ac0b9642c4973cd5a20870aa3fd0a1efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2b4dae58703f188dd7ec4e6b9c4e76"><td class="memItemLeft" align="right" valign="top"><a id="aab2b4dae58703f188dd7ec4e6b9c4e76"></a>
typedef <a class="el" href="structopt__double.html">opt_double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#aab2b4dae58703f188dd7ec4e6b9c4e76">opt_f64</a></td></tr>
<tr class="memdesc:aab2b4dae58703f188dd7ec4e6b9c4e76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for <a class="el" href="structopt__double.html" title="An optional type for wrapping a non-NAN double value.">opt_double</a> available if <code>OPTIONALS_WITH_RUSTY_NAMES</code> is defined. <br /></td></tr>
<tr class="separator:aab2b4dae58703f188dd7ec4e6b9c4e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:addfb05740c0220faaea7030f0111965e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="optional_8h.html#addfb05740c0220faaea7030f0111965e">optional_state_t</a> { <a class="el" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530">OPT_NONE</a>
, <a class="el" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a>
 }</td></tr>
<tr class="separator:addfb05740c0220faaea7030f0111965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8ce69d4c44fc80e776a13d5af0e0d74c"><td class="memItemLeft" align="right" valign="top"><a id="a8ce69d4c44fc80e776a13d5af0e0d74c"></a>
static <a class="el" href="structopt__int8__t.html">opt_int8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_int8_t</b> (void)</td></tr>
<tr class="separator:a8ce69d4c44fc80e776a13d5af0e0d74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f6db8238def1548f6f36dd5cb98b70"><td class="memItemLeft" align="right" valign="top"><a id="a26f6db8238def1548f6f36dd5cb98b70"></a>
static <a class="el" href="structopt__uint8__t.html">opt_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_uint8_t</b> (void)</td></tr>
<tr class="separator:a26f6db8238def1548f6f36dd5cb98b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02210fd1207cffa59bfe97962a84d121"><td class="memItemLeft" align="right" valign="top"><a id="a02210fd1207cffa59bfe97962a84d121"></a>
static <a class="el" href="structopt__int16__t.html">opt_int16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_int16_t</b> (void)</td></tr>
<tr class="separator:a02210fd1207cffa59bfe97962a84d121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab262dbd3c834291aa0274b55caf74d68"><td class="memItemLeft" align="right" valign="top"><a id="ab262dbd3c834291aa0274b55caf74d68"></a>
static <a class="el" href="structopt__uint16__t.html">opt_uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_uint16_t</b> (void)</td></tr>
<tr class="separator:ab262dbd3c834291aa0274b55caf74d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43470d66d1e7861590a8d9a51afef5b3"><td class="memItemLeft" align="right" valign="top"><a id="a43470d66d1e7861590a8d9a51afef5b3"></a>
static <a class="el" href="structopt__int32__t.html">opt_int32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_int32_t</b> (void)</td></tr>
<tr class="separator:a43470d66d1e7861590a8d9a51afef5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9ae82be76ea09239e50f4cb5160f33"><td class="memItemLeft" align="right" valign="top"><a id="a0a9ae82be76ea09239e50f4cb5160f33"></a>
static <a class="el" href="structopt__uint32__t.html">opt_uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_uint32_t</b> (void)</td></tr>
<tr class="separator:a0a9ae82be76ea09239e50f4cb5160f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665db5720a4e71ce062888e337b911e5"><td class="memItemLeft" align="right" valign="top"><a id="a665db5720a4e71ce062888e337b911e5"></a>
static <a class="el" href="structopt__int64__t.html">opt_int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_int64_t</b> (void)</td></tr>
<tr class="separator:a665db5720a4e71ce062888e337b911e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73069222c51cff6bd918314bcc28eb65"><td class="memItemLeft" align="right" valign="top"><a id="a73069222c51cff6bd918314bcc28eb65"></a>
static <a class="el" href="structopt__uint64__t.html">opt_uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_uint64_t</b> (void)</td></tr>
<tr class="separator:a73069222c51cff6bd918314bcc28eb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790daaa92f310c0b6b4742a5dae60fc9"><td class="memItemLeft" align="right" valign="top"><a id="a790daaa92f310c0b6b4742a5dae60fc9"></a>
static <a class="el" href="optional_8h.html#a148e4316703b359faa171e06869cecbd">opt_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_size_t</b> (size_t value)</td></tr>
<tr class="separator:a790daaa92f310c0b6b4742a5dae60fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d917e3fa371b1c808c3c74fdada296b"><td class="memItemLeft" align="right" valign="top"><a id="a6d917e3fa371b1c808c3c74fdada296b"></a>
static <a class="el" href="structopt__float.html">opt_float</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_float</b> (float x)</td></tr>
<tr class="separator:a6d917e3fa371b1c808c3c74fdada296b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019b151095f94e947d804382c22c346e"><td class="memItemLeft" align="right" valign="top"><a id="a019b151095f94e947d804382c22c346e"></a>
static <a class="el" href="structopt__double.html">opt_double</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_double</b> (double x)</td></tr>
<tr class="separator:a019b151095f94e947d804382c22c346e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9827866a2dff82958893681a2e10016b"><td class="memItemLeft" align="right" valign="top"><a id="a9827866a2dff82958893681a2e10016b"></a>
static <a class="el" href="optional_8h.html#a939ecf6b6e49cc27531fe042eb97f979">opt_i8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_i8</b> (int8_t value)</td></tr>
<tr class="separator:a9827866a2dff82958893681a2e10016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6e5bfbd03e19e93d424569c8980ddd"><td class="memItemLeft" align="right" valign="top"><a id="a6c6e5bfbd03e19e93d424569c8980ddd"></a>
static <a class="el" href="optional_8h.html#ad183ec0bf19896b17bb80f5cbac7f043">opt_u8</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_u8</b> (uint8_t value)</td></tr>
<tr class="separator:a6c6e5bfbd03e19e93d424569c8980ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c78a27df91ac5ef1abc59669004c80"><td class="memItemLeft" align="right" valign="top"><a id="a09c78a27df91ac5ef1abc59669004c80"></a>
static <a class="el" href="optional_8h.html#aa3cedb1b96c9646f26da0cc0a02e24c9">opt_i16</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_i16</b> (int16_t value)</td></tr>
<tr class="separator:a09c78a27df91ac5ef1abc59669004c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac249be88b48406c0bd188ba391edc787"><td class="memItemLeft" align="right" valign="top"><a id="ac249be88b48406c0bd188ba391edc787"></a>
static <a class="el" href="optional_8h.html#afa86371541fc193318f70139543e1aa2">opt_u16</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_u16</b> (uint16_t value)</td></tr>
<tr class="separator:ac249be88b48406c0bd188ba391edc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea0f9a4356365d67a793cd4ae0c817f"><td class="memItemLeft" align="right" valign="top"><a id="a9ea0f9a4356365d67a793cd4ae0c817f"></a>
static <a class="el" href="optional_8h.html#a58bb9d2f4e966598a2035a4cc0979574">opt_i32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_i32</b> (int32_t value)</td></tr>
<tr class="separator:a9ea0f9a4356365d67a793cd4ae0c817f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4f461a8919e5fc480bdc3e769ba600"><td class="memItemLeft" align="right" valign="top"><a id="aba4f461a8919e5fc480bdc3e769ba600"></a>
static <a class="el" href="optional_8h.html#a2da5e818472ac3798255864399436409">opt_u32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_u32</b> (uint32_t value)</td></tr>
<tr class="separator:aba4f461a8919e5fc480bdc3e769ba600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaa91219272002e4f20b092acfdb58d"><td class="memItemLeft" align="right" valign="top"><a id="a3eaa91219272002e4f20b092acfdb58d"></a>
static <a class="el" href="optional_8h.html#aadf856309d66cc728bc6301aaed6105b">opt_i64</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_i64</b> (int64_t value)</td></tr>
<tr class="separator:a3eaa91219272002e4f20b092acfdb58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f28dafafa21153d90348a97db1f8cc"><td class="memItemLeft" align="right" valign="top"><a id="a50f28dafafa21153d90348a97db1f8cc"></a>
static <a class="el" href="optional_8h.html#a983e54c1bf0670e5f518408e786a44c7">opt_u64</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_u64</b> (uint64_t value)</td></tr>
<tr class="separator:a50f28dafafa21153d90348a97db1f8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ace087a28c06ef9bf45b976f4241731"><td class="memItemLeft" align="right" valign="top"><a id="a5ace087a28c06ef9bf45b976f4241731"></a>
static <a class="el" href="optional_8h.html#abf9d6a40124de05b87228c94a938eaf2">opt_usize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_usize</b> (size_t value)</td></tr>
<tr class="separator:a5ace087a28c06ef9bf45b976f4241731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07841705f0865d06d0cd866a412efacf"><td class="memItemLeft" align="right" valign="top"><a id="a07841705f0865d06d0cd866a412efacf"></a>
static <a class="el" href="optional_8h.html#ac0b9642c4973cd5a20870aa3fd0a1efc">opt_f32</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_f32</b> (float value)</td></tr>
<tr class="separator:a07841705f0865d06d0cd866a412efacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b29b9b7432b122e8cd2b219f9a96b6d"><td class="memItemLeft" align="right" valign="top"><a id="a3b29b9b7432b122e8cd2b219f9a96b6d"></a>
static <a class="el" href="optional_8h.html#aab2b4dae58703f188dd7ec4e6b9c4e76">opt_f64</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_f64</b> (double value)</td></tr>
<tr class="separator:a3b29b9b7432b122e8cd2b219f9a96b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb53aec43099b4519546fbbfc4434063"><td class="memItemLeft" align="right" valign="top"><a id="aeb53aec43099b4519546fbbfc4434063"></a>
static <a class="el" href="structopt__str.html">opt_str</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_str</b> (char *x)</td></tr>
<tr class="separator:aeb53aec43099b4519546fbbfc4434063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09da930d05e2ba3e097d525cd1395a6a"><td class="memItemLeft" align="right" valign="top"><a id="a09da930d05e2ba3e097d525cd1395a6a"></a>
static <a class="el" href="structopt__str__const.html">opt_str_const</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_str_const</b> (const char *x)</td></tr>
<tr class="separator:a09da930d05e2ba3e097d525cd1395a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e88efd0c43c1977591a28fa37d9d767"><td class="memItemLeft" align="right" valign="top"><a id="a2e88efd0c43c1977591a28fa37d9d767"></a>
static <a class="el" href="structopt__vect2__t.html">opt_vect2_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_vect2_t</b> (<a class="el" href="structvect2__t.html">vect2_t</a> x)</td></tr>
<tr class="separator:a2e88efd0c43c1977591a28fa37d9d767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a75ad4607e24e0282bd62a2d9255c5c"><td class="memItemLeft" align="right" valign="top"><a id="a8a75ad4607e24e0282bd62a2d9255c5c"></a>
static <a class="el" href="structopt__vect3__t.html">opt_vect3_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_vect3_t</b> (<a class="el" href="structvect3__t.html">vect3_t</a> x)</td></tr>
<tr class="separator:a8a75ad4607e24e0282bd62a2d9255c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bd6f823aea54c3f4268f7a0c96f20b"><td class="memItemLeft" align="right" valign="top"><a id="a06bd6f823aea54c3f4268f7a0c96f20b"></a>
static <a class="el" href="structopt__vect3l__t.html">opt_vect3l_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_vect3l_t</b> (<a class="el" href="structvect3l__t.html">vect3l_t</a> x)</td></tr>
<tr class="separator:a06bd6f823aea54c3f4268f7a0c96f20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5faea65ba6dce9ef37a6e3236af79ba"><td class="memItemLeft" align="right" valign="top"><a id="af5faea65ba6dce9ef37a6e3236af79ba"></a>
static <a class="el" href="structopt__geo__pos2__t.html">opt_geo_pos2_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_geo_pos2_t</b> (<a class="el" href="structgeo__pos2__t.html">geo_pos2_t</a> x)</td></tr>
<tr class="separator:af5faea65ba6dce9ef37a6e3236af79ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2df3e60179b38033a0cfa01d95c9bb9"><td class="memItemLeft" align="right" valign="top"><a id="af2df3e60179b38033a0cfa01d95c9bb9"></a>
static <a class="el" href="structopt__geo__pos3__t.html">opt_geo_pos3_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_geo_pos3_t</b> (<a class="el" href="structgeo__pos3__t.html">geo_pos3_t</a> x)</td></tr>
<tr class="separator:af2df3e60179b38033a0cfa01d95c9bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9500f2ec584a4f65510c18d0b429d1a2"><td class="memItemLeft" align="right" valign="top"><a id="a9500f2ec584a4f65510c18d0b429d1a2"></a>
static <a class="el" href="structopt__geo__pos2__32__t.html">opt_geo_pos2_32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_geo_pos2_32_t</b> (<a class="el" href="structgeo__pos2__32__t.html">geo_pos2_32_t</a> x)</td></tr>
<tr class="separator:a9500f2ec584a4f65510c18d0b429d1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf9bbe4be50ce3bceb8907966aa3fba"><td class="memItemLeft" align="right" valign="top"><a id="abcf9bbe4be50ce3bceb8907966aa3fba"></a>
static <a class="el" href="structopt__geo__pos3__32__t.html">opt_geo_pos3_32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>opt_into_geo_pos3_32_t</b> (<a class="el" href="structgeo__pos3__32__t.html">geo_pos3_32_t</a> x)</td></tr>
<tr class="separator:abcf9bbe4be50ce3bceb8907966aa3fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="autotoc_md10"></a>
Optional Types</h1>
<p>This file provides a simplified Rust-like optional type machinery for C11 code. In Rust, the <code>Option&lt;T&gt;</code> type allows expressing the concept of a value being optionally present, with support from the type checker. This helps avoid inadvertently using uninitialized or invalid data without employing proper checks.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Principles of Operation</h2>
<p>An optional type is a structure which wraps an underlying type and enforces explicit checks for value presence at compile time. Rather than relying on checking the value of a variable at runtime for validity (e.g. checking a pointer for <code>NULL</code>), the validity check is enforced by preventing access to the wrapped value without first performing a validity-checking unwrapping operation. We refer to the state of the value being valid as the "SOME" state, whereas the invalid state is called "NONE."</p>
<p>For example, to wrap an <code>int32_t</code> as an optional type, we declare a structure of type <code><a class="el" href="structopt__int32__t.html" title="An optional type for wrapping an int32_t value.">opt_int32_t</a></code> and store both the integer value as well as the validity state in the structure (don't worry, you don't need declare this structure yourself, <code><a class="el" href="optional_8h.html">optional.h</a></code> provides lots of canned types, as well as simple construction macros for your own types, see below). Users of the optional type are then forced to perform one of the several available unwrapping operations on the optional, which perform the validity check.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Constructing Optional Values</h2>
<p>Use one of the following two macros to construct new optional values:</p>
<ol type="1">
<li><code><a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME(T expr)</a> -&gt; opt_T</code>: returns an optional value of type <code>opt_T</code> in the SOME state from a provided expression argument. Please note that the optional type may perform integrity checks on the value, to make sure that it really conforms to the SOME specification on the type (what constitutes a valid SOME value depends on the type, see below).</li>
<li><code><a class="el" href="optional_8h.html#a8a1dd117c8e0f7c9a98acd48235cd2f8" title="Constructs a new optional value in the NONE state.">NONE(T)</a> -&gt; opt_T</code>: returns an optional value of type <code>opt_T</code> in the NONE state. The argument to this macro is the type name of the optional (the part after the <code>opt_</code> prefix of the optional type, not necessarily the contained C type).</li>
</ol>
<h2><a class="anchor" id="autotoc_md13"></a>
Manipulating Optional Values</h2>
<p>To manipulate an optional value, use one of the following macros:</p>
<ol type="1">
<li><code><a class="el" href="optional_8h.html#a67eb6100d3f12d967c23fd51eaa80d37" title="Returns true if the optional is in the SOME state.">IS_SOME(opt_T opt)</a> -&gt; bool</code>: returns true if the optional <code>opt</code> is in the SOME state.</li>
<li><code><a class="el" href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536" title="Returns true if the optional is in the NONE state.">IS_NONE(opt_T opt)</a> -&gt; bool</code>: returns true if the optional <code>opt</code> is in the NONE state.</li>
<li><code><a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH(opt_T opt, T &amp;out_value)</a> -&gt; optional_state_t</code>: this operation checks the state of the optional <code>opt</code>. If it is in the SOME state, the wrapped value is written to <code>&amp;out_value</code> and the entire <code>MATCH</code> operation returns the <code>OPT_SOME</code> enumeration. If the optional is in the NONE state, the <code>&amp;out_value</code> reference is filled with an invalid value and the <code>MATCH</code> operation returns <code>OPT_NONE</code>.</li>
<li><code><a class="el" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769" title="Extracts the value of the optional unconditionally.">UNWRAP(opt_T opt)</a> -&gt; T</code>: this operation returns the wrapped value contained within the optional type, if the optional is in the SOME state. If the state is NONE, then attempting this operation causes a runtime assertion failure and panic. <code><a class="el" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769" title="Extracts the value of the optional unconditionally.">UNWRAP()</a></code> should only be used for testing, or for cases where another check has already been performed, guaranteeing that the value is the SOME state.</li>
<li><code><a class="el" href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d" title="Extracts the value of the optional, or evaluates to a fallback value.">UNWRAP_OR(opt_T opt, T dfl_value)</a> -&gt; T</code>: if the optional <code>opt</code> is in the SOME state, this operation returns the wrapped value of type <code>T</code>. If the optional value is in the NONE state, this operation returns <code>dfl_value</code> instead.</li>
<li><code><a class="el" href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e" title="Extracts the value of the optional, or yields a fallback value with lazy evaluation.">UNWRAP_OR_ELSE(opt_T opt, T (*func), void *arg)</a> -&gt; T</code>: if the optional <code>opt</code> is in the SOME state, returns the wrapped value of type <code>T</code>. If the optional value is in the NONE state, lazily calls <code>func</code> with <code>arg</code> and returns its return value.</li>
<li><code><a class="el" href="optional_8h.html#ab65621263872982e2ecf95bb2c190810" title="Selects between two optional values based on whether the first optional is in the SOME state.">OPT_OR(opt_T a, opt_T b)</a> -&gt; opt_T</code>: if the state of the optional <code>a</code> is SOME, returns <code>a</code>. Otherwise, returns <code>b</code>.</li>
<li><code><a class="el" href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8" title="Selects between two optional values based on whether the first optional is in the SOME state....">OPT_OR_ELSE(opt_T a, opt_T (*func), void *arg)</a> -&gt; opt_T</code>: if the state of <code>a</code> is SOME, returns <code>a</code>. Otherwise, lazily calls <code>func</code> with <code>arg</code> and returns its return value.</li>
</ol>
<h2><a class="anchor" id="autotoc_md14"></a>
Interoperating with C++ Code</h2>
<p>While the <code><a class="el" href="optional_8h.html">optional.h</a></code> functionality is primarily designed for C11 code, optional values can be both manipulated as well as constructed from C++ code. This bridge is primarily provided for compatibility in heterogeneous codebases.</p>
<p>C++ doesn't have the same kind of type-matching mechanism as C11's <code>_Generic</code> statement has, so when called from C++ code, the above macros need an explicit type name argument. For example, for a optional value of type <code><a class="el" href="structopt__float.html" title="An optional type for wrapping a non-NAN float value.">opt_float</a></code>, you must modify the macro invocations from C++ code as follows:</p>
<ol type="1">
<li><code><a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME(x)</a></code> becomes <code><a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME(float, x)</a></code></li>
<li><code><a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH(opt, out_val)</a></code> becomes <code><a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH(float, opt, out_val)</a></code></li>
<li>(etc.)</li>
</ol>
<h2><a class="anchor" id="autotoc_md15"></a>
Available Built-In Optional Types</h2>
<p>This list summarizes all automatically provided optional types directly from libacfutils. See the next section on how to add extra custom optional types for your own needs.</p>
<ol type="1">
<li>Most sized standard C integer types: <code><a class="el" href="structopt__int8__t.html" title="An optional type for wrapping an int8_t value.">opt_int8_t</a></code>, <code><a class="el" href="structopt__uint8__t.html" title="An optional type for wrapping a uint8_t value.">opt_uint8_t</a></code>, etc. through to <code><a class="el" href="structopt__uint64__t.html" title="An optional type for wrapping a uint64_t value.">opt_uint64_t</a></code>. The type <code>opt_size_t</code> is a type alias, which can be used for wrapping a <code>size_t</code>.</li>
<li>Single-precision and double-precision floating point types: <code><a class="el" href="structopt__float.html" title="An optional type for wrapping a non-NAN float value.">opt_float</a></code> and <code><a class="el" href="structopt__double.html" title="An optional type for wrapping a non-NAN double value.">opt_double</a></code>. These types are explicitly disallow <code>NAN</code> values in the SOME state.</li>
<li>Vector types from <code><a class="el" href="geom_8h.html">geom.h</a></code>: <code><a class="el" href="structopt__vect2__t.html" title="An optional type for wrapping a non-NULL vect2_t value.">opt_vect2_t</a></code>, <code><a class="el" href="structopt__vect3__t.html" title="An optional type for wrapping a non-NULL vect3_t value.">opt_vect3_t</a></code> and <code><a class="el" href="structopt__vect3l__t.html" title="An optional type for wrapping a non-NULL vect3l_t value.">opt_vect3l_t</a></code>. These types explicitly disallow the matching <code>NULL_VECT*</code> values in the SOME state.</li>
<li>Geographic coordinate types from <code><a class="el" href="geom_8h.html">geom.h</a></code>: <code><a class="el" href="structopt__geo__pos2__t.html" title="An optional type for wrapping a non-NULL geo_pos2_t value.">opt_geo_pos2_t</a></code>, <code><a class="el" href="structopt__geo__pos3__t.html" title="An optional type for wrapping a non-NULL geo_pos3_t value.">opt_geo_pos3_t</a></code>, <code><a class="el" href="structopt__geo__pos2__32__t.html" title="An optional type for wrapping a non-NULL geo_pos2_32_t value.">opt_geo_pos2_32_t</a></code> and <code><a class="el" href="structopt__geo__pos3__32__t.html" title="An optional type for wrapping a non-NULL geo_pos3_32_t value.">opt_geo_pos3_32_t</a></code>. These types explicitly disallow the matching <code>NULL_GEO_POS*</code> values in the SOME state.</li>
<li>C string types <code><a class="el" href="structopt__str.html" title="An optional type for wrapping a non-NULL char * value.">opt_str</a></code> (containing a <code>char *</code>) and <code><a class="el" href="structopt__str__const.html" title="An optional type for wrapping a non-NULL char const * value.">opt_str_const</a></code> (containing a <code>char const *</code>). These types explicitly disallow passing a <code>NULL</code> pointer in the SOME state.</li>
</ol>
<p><a class="anchor" id="custom_opt_types"></a></p>
<h2><a class="anchor" id="autotoc_md16"></a>
Adding Your Own Custom Optional Types</h2>
<p>Due to the preprocessor-driven nature of the <code><a class="el" href="optional_8h.html">optional.h</a></code> machinery, adding custom optional types is a bit tricky, but possible. To do so, you must first create your header file, which will <code>#include &lt;<a class="el" href="optional_8h.html">acfutils/optional.h</a>&gt;</code> at the start. It should then include any headers for declarations of the types you wish to wrap into new optional types. Any code that wants to use these new optional types must then include this custom header, to allow for properly selecting the implementation using the standard <code>SOME</code>, <code>MATCH</code> and similar macros. Example header template so far: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef _my_optional_h_</span></div>
<div class="line"><span class="preprocessor">#define _my_optional_h_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8h.html">acfutils/optional.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;my_type_1.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;my_type_2.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// _my_optional_h_</span></div>
<div class="ttc" id="aoptional_8h_html"><div class="ttname"><a href="optional_8h.html">optional.h</a></div></div>
</div><!-- fragment --><p> With the headers included, we can proceed to implement each optional type using the <a class="el" href="optional_8h.html#a784e18ac9e8950db47089383372b2e93" title="Declares a custom optional type with implicit NONE encoding.">IMPL_OPTIONAL_IMPLICIT()</a> or <a class="el" href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a" title="Declares a custom optional type with explicit NONE encoding.">IMPL_OPTIONAL_EXPLICIT()</a> macros. See each macro for details on what they do. </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef _my_optional_h_</span></div>
<div class="line"><span class="preprocessor">#define _my_optional_h_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8h.html">acfutils/optional.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;my_type_1.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;my_type_2.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a">IMPL_OPTIONAL_EXPLICIT</a>(my_type_1, my_type_1, my_1_none_value)</div>
<div class="line"><a class="code" href="optional_8h.html#a784e18ac9e8950db47089383372b2e93">IMPL_OPTIONAL_IMPLICIT</a>(my_type_2, my_type_2, my_2_none_value,</div>
<div class="line">    check_type_2_is_none(x))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// _my_optional_h_</span></div>
<div class="ttc" id="aoptional_8h_html_a308278970253212c8e9f8c0ae317b96a"><div class="ttname"><a href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a">IMPL_OPTIONAL_EXPLICIT</a></div><div class="ttdeci">#define IMPL_OPTIONAL_EXPLICIT(type_name, c_type)</div><div class="ttdoc">Declares a custom optional type with explicit NONE encoding.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00308">optional.h:308</a></div></div>
<div class="ttc" id="aoptional_8h_html_a784e18ac9e8950db47089383372b2e93"><div class="ttname"><a href="optional_8h.html#a784e18ac9e8950db47089383372b2e93">IMPL_OPTIONAL_IMPLICIT</a></div><div class="ttdeci">#define IMPL_OPTIONAL_IMPLICIT(type_name, c_type, none_value, none_check)</div><div class="ttdoc">Declares a custom optional type with implicit NONE encoding.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00491">optional.h:491</a></div></div>
</div><!-- fragment --><p> We have now constructed all of the necessary typedefs and inline functions to manipulate each optional type. Lastly, we need to link these new types into the master auto-selection macro inside of <code><a class="el" href="optional_8h.html">optional.h</a></code>. We do this by simply redefining the <code>OPTIONAL_TYPE_LIST</code> macro, filling it with our types: </p><div class="fragment"><div class="line"><span class="preprocessor">#ifndef _my_optional_h_</span></div>
<div class="line"><span class="preprocessor">#define _my_optional_h_</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="optional_8h.html">acfutils/optional.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;my_type_1.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;my_type_2.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a">IMPL_OPTIONAL_EXPLICIT</a>(my_type_1, my_type_1, my_1_none_value)</div>
<div class="line"><a class="code" href="optional_8h.html#a784e18ac9e8950db47089383372b2e93">IMPL_OPTIONAL_IMPLICIT</a>(my_type_2, my_type_2, my_2_none_value,</div>
<div class="line">    check_type_2_is_none(x))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef OPTIONAL_TYPE_LIST</span></div>
<div class="line"><span class="preprocessor">#define OPTIONAL_TYPE_LIST(op_name) \</span></div>
<div class="line"><span class="preprocessor">    OPTIONAL_TYPE_LIST_ADD(my_type_1, my_type_1, op_name), \</span></div>
<div class="line"><span class="preprocessor">    OPTIONAL_TYPE_LIST_ADD(my_type_2, my_type_2, op_name)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif  </span><span class="comment">// _my_optional_h_</span></div>
</div><!-- fragment --><p> Please note that the <a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f" title="Overridable list of custom optional types provided by your code.">OPTIONAL_TYPE_LIST()</a> macro must be defined to take an <code>op_name</code> argument and must pass it through to the <a class="el" href="optional_8h.html#a783fdd25c33e6bc7f19275548404e578" title="Appends a new entry to the definition of the OPTIONAL_TYPE_LIST() macro.">OPTIONAL_TYPE_LIST_ADD()</a> macro invocations within. This is required to correctly construct the invoked function names when an optional operation macro is instantiated.</p>
<p>We have now extended the optional list with our new custom optional types, <code>opt_my_type_1</code> and <code>opt_my_type_2</code> (containing values of type <code>my_type_1</code> and <code>my_type_2</code> respectively). All the standard optional types from libacfutils remain available as well.</p>
<p>There are some important caveats to consider when adding custom optional types:</p>
<ul>
<li>You can only add optional types for base C types which the compiler can distinguish during type determination using the <code>_Generic</code> operator. This means you cannot add another optional type for something like <code>int32_t</code>, which is already in the library, as the compiler couldn't decide which implementation to call. If you want you can however add a type alias to an existing known optional type using the <a class="el" href="optional_8h.html#a095de7c69ad75a230d72f24f5eff5809" title="Declares a type alias for an existing optional type.">IMPL_OPTIONAL_ALIAS()</a> macro. This is how <code>opt_size_t</code> is implemented (it is an alias for <code><a class="el" href="structopt__uint64__t.html" title="An optional type for wrapping a uint64_t value.">opt_uint64_t</a></code>).</li>
<li>You must only define the <code>OPTIONAL_TYPE_LIST</code> macro once. You cannot spread its definition over multiple files, each adding its own optional types. Only the last definition of the macro would actually get used.</li>
<li>While it is technically possible to declare an optional void pointer type, doing so is strongly discouraged, as that bypasses the compiler's type checks. You should almost always define an as narrowly scoped type-specific optional pointer as possible. </li>
</ul>

<p class="definition">Definition in file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af50612b5c0dc6f77d51269f51e935785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50612b5c0dc6f77d51269f51e935785">&#9670;&nbsp;</a></span>IF_LET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IF_LET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vartype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">varname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    { \</div>
<div class="line">        vartype __if_let_tmp_##varname; \</div>
<div class="line">        <span class="comment">/* \</span></div>
<div class="line"><span class="comment">         * The void pointer cast here gets rid of a C language quirk \</span></div>
<div class="line"><span class="comment">         * where const and non-const pointers aren&#39;t technically \</span></div>
<div class="line"><span class="comment">         * compatible for referencing. Thus to avoid having to force \</span></div>
<div class="line"><span class="comment">         * the caller to use a mutable reference when all they want \</span></div>
<div class="line"><span class="comment">         * is an immutable reference, we perform type erasure here. \</span></div>
<div class="line"><span class="comment">         */</span> \</div>
<div class="line">        if (<a class="code" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a>((opt), (<span class="keywordtype">void</span> *)&amp;__if_let_tmp_##varname) == \</div>
<div class="line">            <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a>) { \</div>
<div class="line">            vartype varname = __if_let_tmp_##varname;</div>
<div class="ttc" id="aoptional_8h_html_ace2138afa1ae8fb5f0e9127f90098469"><div class="ttname"><a href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a></div><div class="ttdeci">#define MATCH(opt, out_value)</div><div class="ttdoc">Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01046">optional.h:1046</a></div></div>
<div class="ttc" id="aoptional_8h_html_addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f"><div class="ttname"><a href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a></div><div class="ttdeci">@ OPT_SOME</div><div class="ttdoc">State denoting that the optional contains a valid value.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00275">optional.h:275</a></div></div>
</div><!-- fragment -->
<p>Allows constructing Rust-like if-let statements in C. </p>
<p>This macro helps in assembling Rust-like if-let statements, which scope their variables to prevent inadvertently leaking them outside of the properly matched scope (as might otherwise happen with the <a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH()</a> macro).</p>
<p>This macro, along with its accompanying IF_LET_END and IF_LET_ELSE macros replaces the normal control flow constructs, to provide automatic scoping.</p>
<div class="fragment"><div class="line"><a class="code" href="structopt__float.html">opt_float</a> my_option;</div>
<div class="line"><a class="code" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785">IF_LET</a>(<span class="keywordtype">float</span>, foo, my_option)</div>
<div class="line">    <span class="comment">// place your condition-met code into this block</span></div>
<div class="line">    <span class="comment">// `foo&#39; is available here (and only here) to contain the</span></div>
<div class="line">    <span class="comment">// SOME state value of `my_option&#39;</span></div>
<div class="line">    use_foo(foo);</div>
<div class="line">IF_LET_END</div>
<div class="ttc" id="aoptional_8h_html_af50612b5c0dc6f77d51269f51e935785"><div class="ttname"><a href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785">IF_LET</a></div><div class="ttdeci">#define IF_LET(vartype, varname, opt)</div><div class="ttdoc">Allows constructing Rust-like if-let statements in C.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01496">optional.h:1496</a></div></div>
<div class="ttc" id="astructopt__float_html"><div class="ttname"><a href="structopt__float.html">opt_float</a></div><div class="ttdoc">An optional type for wrapping a non-NAN float value.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00752">optional.h:752</a></div></div>
</div><!-- fragment --><p> In the above example, <code>foo</code> is prevented from leaking outside of the if block scope, thus stopping accidentally using it when no value was contained in the optional type. To add an else block to this kind of block, use: </p><div class="fragment"><div class="line"><a class="code" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785">IF_LET</a>(<span class="keywordtype">float</span>, foo, my_option)</div>
<div class="line">    use_foo(foo);</div>
<div class="line">IF_LET_ELSE</div>
<div class="line">    <span class="comment">// `foo&#39; doesn&#39;t exist here</span></div>
<div class="line">    do_something_else();</div>
<div class="line">IF_LET_END</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01496">1496</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a20ec60060bf83079070ef896e6a46a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ec60060bf83079070ef896e6a46a9c">&#9670;&nbsp;</a></span>IF_LET_AS_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IF_LET_AS_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">vartype, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">varname, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    { \</div>
<div class="line">        vartype __if_let_tmp_##varname; \</div>
<div class="line">        if (<a class="code" href="optional_8h.html#ab9fa7456dfc3fb1e8896b95c3aa80bf2">MATCH_AS_REF</a>((opt), (<span class="keywordtype">void</span> *)&amp;__if_let_tmp_##varname) == \</div>
<div class="line">            <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a>) { \</div>
<div class="line">            vartype varname = __if_let_tmp_##varname;</div>
<div class="ttc" id="aoptional_8h_html_ab9fa7456dfc3fb1e8896b95c3aa80bf2"><div class="ttname"><a href="optional_8h.html#ab9fa7456dfc3fb1e8896b95c3aa80bf2">MATCH_AS_REF</a></div><div class="ttdeci">#define MATCH_AS_REF(opt, out_value_p)</div><div class="ttdoc">Extracts an immutable reference to the value embedded in the optional and returns the optional_state_...</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01088">optional.h:1088</a></div></div>
</div><!-- fragment -->
<p>Same as <a class="el" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785" title="Allows constructing Rust-like if-let statements in C.">IF_LET()</a> macro, but returns reference to the value. </p>
<p>This macro works in a similar manner as <a class="el" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785" title="Allows constructing Rust-like if-let statements in C.">IF_LET()</a>, but instead returning the optional in the SOME case by value, the optional is returned by reference (as in <a class="el" href="optional_8h.html#ab9fa7456dfc3fb1e8896b95c3aa80bf2" title="Extracts an immutable reference to the value embedded in the optional and returns the optional_state_...">MATCH_AS_REF()</a>). Example: </p><div class="fragment"><div class="line">opt_object_t maybe_obj;</div>
<div class="line"><a class="code" href="optional_8h.html#a20ec60060bf83079070ef896e6a46a9c">IF_LET_AS_REF</a>(object_t *, obj, maybe_obj)</div>
<div class="line">    <span class="comment">// `obj&#39; points into `maybe_obj&#39;</span></div>
<div class="line">    use_obj_ref(obj);</div>
<div class="line">IF_LET_END</div>
<div class="ttc" id="aoptional_8h_html_a20ec60060bf83079070ef896e6a46a9c"><div class="ttname"><a href="optional_8h.html#a20ec60060bf83079070ef896e6a46a9c">IF_LET_AS_REF</a></div><div class="ttdeci">#define IF_LET_AS_REF(vartype, varname, opt)</div><div class="ttdoc">Same as IF_LET() macro, but returns reference to the value.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01518">optional.h:1518</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01518">1518</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a095de7c69ad75a230d72f24f5eff5809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095de7c69ad75a230d72f24f5eff5809">&#9670;&nbsp;</a></span>IMPL_OPTIONAL_ALIAS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMPL_OPTIONAL_ALIAS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">orig_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alias_type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">alias_c_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a type alias for an existing optional type. </p>
<p>This function constructs a <code>typedef</code>, as well as support functions to make the new type name function equally to the old one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">orig_type_name</td><td>The type name of the original type. The type name is the part following the <code>opt_</code> prefix in the optional type and need not exactly correspond to the C type of the embedded value. </td></tr>
    <tr><td class="paramname">alias_type_name</td><td>The new aliased type name for the optional type. This can subsequently be used in any place where the original type name would have been. </td></tr>
    <tr><td class="paramname">alias_c_type</td><td>The C type of the aliased type. This type must be directly compatible to the embedded type of the original optional type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00651">651</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a308278970253212c8e9f8c0ae317b96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a308278970253212c8e9f8c0ae317b96a">&#9670;&nbsp;</a></span>IMPL_OPTIONAL_EXPLICIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMPL_OPTIONAL_EXPLICIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c_type&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a custom optional type with explicit NONE encoding. </p>
<p>This macro constructs all the necessary typedefs and inline functions for your custom optional type, allowing it to be linked into the optional type selection logic in macros such as <code><a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME(x)</a></code> or <code><a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH(x, out)</a></code>. The "explicit" nature of this optional means that the SOME/NONE state of the value cannot be inferred and checked from the value itself, but rather must be stored directly in the optional state. This inflates the stored type by an extra 32 bits on most platforms, because the value of the <code>optional_state_t</code> enum must be embedded. If your value supports implicit SOME/NONE distinction (such as a floating point number with <code>NAN</code>, or a pointer being <code>NULL</code>), then you can use the <a class="el" href="optional_8h.html#a784e18ac9e8950db47089383372b2e93" title="Declares a custom optional type with implicit NONE encoding.">IMPL_OPTIONAL_IMPLICIT()</a> macro instead. This provides additional integrity checking, to make sure the caller doesn't attempt to embed an invalid value when constructing the optional type using the <a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME()</a> macro.</p>
<dl class="section note"><dt>Note</dt><dd>Don't forget to also add the type to your <a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f" title="Overridable list of custom optional types provided by your code.">OPTIONAL_TYPE_LIST()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>The type name of the optional type. This will be the name which will appear after the <code>opt_</code> prefix. For example, passing <code>foobar</code> here will result in an optional type named <code>opt_foobar</code>. This string must constitute a well-formed C identifier, as it is used as part of the typedef name, as well as manipulation function names. </td></tr>
    <tr><td class="paramname">c_type</td><td>The actual C type being wrapped by the optional type. This can be any valid C type. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00308">308</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a784e18ac9e8950db47089383372b2e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784e18ac9e8950db47089383372b2e93">&#9670;&nbsp;</a></span>IMPL_OPTIONAL_IMPLICIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IMPL_OPTIONAL_IMPLICIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">none_value, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">none_check&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares a custom optional type with implicit NONE encoding. </p>
<p>This macro constructs all the necessary typedefs and inline functions for your custom optional type, allowing it to be linked into the optional type selection logic in macros such as <code><a class="el" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d" title="Constructs a new optional value in the SOME state.">SOME(x)</a></code> or <code><a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH(x, out)</a></code>. The "implicit" nature of this optional means that the SOME/NONE state of the value is encoded directly in the value itself and can be checked at runtime. This also saves a bit of storage space, since the <code>optional_state_t</code> enum doesn't have to be embedded in the resultant optional type. If the type you want to embed has no specific "NONE" encoded in its representation (for example, integers do not have any specific numerical value which could be considered per-se "invalid"), use the <a class="el" href="optional_8h.html#a308278970253212c8e9f8c0ae317b96a" title="Declares a custom optional type with explicit NONE encoding.">IMPL_OPTIONAL_EXPLICIT()</a> macro instead.</p>
<dl class="section note"><dt>Note</dt><dd>Don't forget to also add the type to your <a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f" title="Overridable list of custom optional types provided by your code.">OPTIONAL_TYPE_LIST()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>The type name of the optional type. This will be the name which will appear after the <code>opt_</code> prefix. For example, passing <code>foobar</code> here will result in an optional type named <code>opt_foobar</code>. This string must constitute a well-formed C identifier, as it is used as part of the typedef name, as well as manipulation function names. </td></tr>
    <tr><td class="paramname">c_type</td><td>The actual C type being wrapped by the optional type. This can be any valid C type. </td></tr>
    <tr><td class="paramname">none_value</td><td>The actual value of the C type which denotes a NONE state. </td></tr>
    <tr><td class="paramname">none_check</td><td>An expression which must return true if the value is NONE. The expression must be formed using a variable named "x", which holds the value to be tested. For example, for floating point numbers, this argument is <code>isnan(x)</code>. For pointers, a good none_check is <code>x == NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00491">491</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ace2138afa1ae8fb5f0e9127f90098469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2138afa1ae8fb5f0e9127f90098469">&#9670;&nbsp;</a></span>MATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_match_, (opt).value)((opt), (out_value))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the value embedded in the optional and returns the <code>optional_state_t</code> enum corresponding to the state. </p>
<p>If the optional is in the SOME state, the wrapped value is written to the <code>out_value</code> argument. If the optional is in the NONE state, the <code>out_value</code> argument is filled with an invalid value.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>out_value</code> argument is mandatory and may not be NULL.</dd></dl>
<p>This macro is intended to be used in one of the following ways:</p>
<ol type="1">
<li>As a switch condition, which is similar to the Rust <code>match</code> value destructuring pattern: <div class="fragment"><div class="line"><span class="keywordtype">float</span> my_value;</div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a>(my_opt_float, &amp;my_value)) {</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a>:</div>
<div class="line">    operate_with(my_value);</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530">OPT_NONE</a>:</div>
<div class="line">    operate_without_any_value();</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aoptional_8h_html_addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530"><div class="ttname"><a href="optional_8h.html#addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530">OPT_NONE</a></div><div class="ttdeci">@ OPT_NONE</div><div class="ttdoc">State denoting that the optional contains no valid value.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00274">optional.h:274</a></div></div>
</div><!-- fragment --></li>
<li>As an if condition, which is similar to a Rust "if-let" statement: <div class="fragment"><div class="line"><span class="keywordtype">float</span> my_value;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a>(my_opt_float, &amp;my_value)) {</div>
<div class="line">    operate_with(my_value);</div>
<div class="line">}</div>
</div><!-- fragment --> </li>
</ol>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01046">1046</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ad597bc0d9a06c841ff83207760bdee87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad597bc0d9a06c841ff83207760bdee87">&#9670;&nbsp;</a></span>MATCH_AS_MUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCH_AS_MUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_value_p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    OPTIONAL_TYPE_SELECTOR(opt_match_as_mut_, (*(opt)).value)\</div>
<div class="line">        ((opt), (out_value_p))</div>
</div><!-- fragment -->
<p>Extracts a reference to the value embedded in the optional and returns the <code>optional_state_t</code> enum corresponding to the state. </p>
<p>This is similar to <a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH()</a>, except the second argument is a reference to a pointer. If the optional value is OPT_SOME, the pointer is filled with a reference to the value contained internally in the optional value. If the optional value is OPT_NONE, the pointer is set to NULL.</p>
<p>The purpose of this macro is to facilitate returning an internal value by reference. This may be necessary, in case a stack-allocated copy of the object cannot be returned from the calling function.</p>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> *my_value_ptr;</div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a>(my_opt_float, &amp;my_value)) {</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a>:</div>
<div class="line">    printf(<span class="stringliteral">&quot;my_value is %f\n&quot;</span>, *my_value_ptr);</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530">OPT_NONE</a>:</div>
<div class="line">    <span class="comment">// my_value_ptr is now NULL</span></div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01125">1125</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ab9fa7456dfc3fb1e8896b95c3aa80bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fa7456dfc3fb1e8896b95c3aa80bf2">&#9670;&nbsp;</a></span>MATCH_AS_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MATCH_AS_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_value_p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    OPTIONAL_TYPE_SELECTOR(opt_match_as_ref_, (*(opt)).value)\</div>
<div class="line">        ((opt), (out_value_p))</div>
</div><!-- fragment -->
<p>Extracts an immutable reference to the value embedded in the optional and returns the <code>optional_state_t</code> enum corresponding to the state. </p>
<p>This is similar to <a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH()</a>, except the second argument is a reference to an immutable pointer. If the optional value is OPT_SOME, the pointer is filled with a reference to the value contained internally in the optional value. If the optional value is OPT_NONE, the pointer is set to NULL.</p>
<p>The purpose of this macro is to facilitate returning an internal value by immutable reference. This may be necessary, in case a stack-allocated copy of the object cannot be returned from the calling function.</p>
<dl class="section note"><dt>Note</dt><dd>If you need a mutable reference to the value contained inside of the optional, use <a class="el" href="optional_8h.html#ad597bc0d9a06c841ff83207760bdee87" title="Extracts a reference to the value embedded in the optional and returns the optional_state_t enum corr...">MATCH_AS_MUT()</a> instead.</dd></dl>
<div class="fragment"><div class="line"><span class="keywordtype">float</span> *my_value_ptr;</div>
<div class="line"><span class="keywordflow">switch</span> (<a class="code" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469">MATCH</a>(my_opt_float, &amp;my_value)) {</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f">OPT_SOME</a>:</div>
<div class="line">    printf(<span class="stringliteral">&quot;my_value is %f\n&quot;</span>, *my_value_ptr);</div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line"><span class="keywordflow">case</span> <a class="code" href="optional_8h.html#addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530">OPT_NONE</a>:</div>
<div class="line">    <span class="comment">// my_value_ptr is now NULL</span></div>
<div class="line">    <span class="keywordflow">break</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#ad597bc0d9a06c841ff83207760bdee87" title="Extracts a reference to the value embedded in the optional and returns the optional_state_t enum corr...">MATCH_AS_MUT()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01088">1088</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a8a1dd117c8e0f7c9a98acd48235cd2f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1dd117c8e0f7c9a98acd48235cd2f8">&#9670;&nbsp;</a></span>NONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NONE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name</td><td>)</td>
          <td>&#160;&#160;&#160;opt_none_ ## type_name()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new optional value in the NONE state. </p>
<p>Due to C's lack of type inference support from return values, you must provide an explicit type name annotation in the <code>type_name</code> argument. This is the latter part of the name of the optional type, e.g. for an <code><a class="el" href="structopt__str.html" title="An optional type for wrapping a non-NULL char * value.">opt_str</a></code> the type name is <code>str</code> and not necessarily the C type designator (which is <code>char *</code> in the case of <code><a class="el" href="structopt__str.html" title="An optional type for wrapping a non-NULL char * value.">opt_str</a></code>).</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="structopt__float.html">opt_float</a> my_func(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (some_condition()) {</div>
<div class="line">         <span class="keywordflow">return</span> <a class="code" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d">SOME</a>(5.0f);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">         <span class="keywordflow">return</span> <a class="code" href="optional_8h.html#a8a1dd117c8e0f7c9a98acd48235cd2f8">NONE</a>(<span class="keywordtype">float</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aoptional_8h_html_a8a1dd117c8e0f7c9a98acd48235cd2f8"><div class="ttname"><a href="optional_8h.html#a8a1dd117c8e0f7c9a98acd48235cd2f8">NONE</a></div><div class="ttdeci">#define NONE(type_name)</div><div class="ttdoc">Constructs a new optional value in the NONE state.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00985">optional.h:985</a></div></div>
<div class="ttc" id="aoptional_8h_html_ad37ae435f25f46c67993270d88bc219d"><div class="ttname"><a href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d">SOME</a></div><div class="ttdeci">#define SOME(expr)</div><div class="ttdoc">Constructs a new optional value in the SOME state.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l00956">optional.h:956</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00985">985</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ad2b197c4eb4243b3a74bac0736911fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b197c4eb4243b3a74bac0736911fc5">&#9670;&nbsp;</a></span>OPT_INTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPT_INTO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">value</td><td>)</td>
          <td>&#160;&#160;&#160;OPTIONAL_TYPE_SELECTOR(opt_into_, (value))(value)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows wrapping an implicitly representable value into a suitable optional. </p>
<p>This macro works by performing a NONE-check on the value itself, to then determine whether the value should be wrapped in a SOME variant, or a NONE variant.</p>
<dl class="section note"><dt>Note</dt><dd>This <em>only</em> works for values which can be implicitly represented in an optional (i.e. they are defined using IMPL_OPTIONAL_IMPLICIT). This is because we rely on the value itself containing enough information to convey its state. Only the following types implemented in libacfutils support implicit conversion into an optional type:<ul>
<li>floating point types <code><a class="el" href="structopt__float.html" title="An optional type for wrapping a non-NAN float value.">opt_float</a></code> and <code><a class="el" href="structopt__double.html" title="An optional type for wrapping a non-NAN double value.">opt_double</a></code></li>
<li>string types <code><a class="el" href="structopt__str.html" title="An optional type for wrapping a non-NULL char * value.">opt_str</a></code> and <code><a class="el" href="structopt__str__const.html" title="An optional type for wrapping a non-NULL char const * value.">opt_str_const</a></code></li>
<li>vector geometric types <code>opt_vect*_t</code></li>
<li>geographic coordinate types <code>opt_geo_pos*_t</code></li>
</ul>
</dd></dl>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> foo();        <span class="comment">// may return NAN to indicate an invalid value</span></div>
<div class="line"><a class="code" href="optional_8h.html#af50612b5c0dc6f77d51269f51e935785">IF_LET</a>(<span class="keywordtype">float</span>, valid_value, <a class="code" href="optional_8h.html#ad2b197c4eb4243b3a74bac0736911fc5">OPT_INTO</a>(foo()))</div>
<div class="line"> <span class="comment">// valid_value is guaranteed to be non-NAN here</span></div>
<div class="line">IF_LET_END</div>
<div class="ttc" id="aoptional_8h_html_ad2b197c4eb4243b3a74bac0736911fc5"><div class="ttname"><a href="optional_8h.html#ad2b197c4eb4243b3a74bac0736911fc5">OPT_INTO</a></div><div class="ttdeci">#define OPT_INTO(value)</div><div class="ttdoc">Allows wrapping an implicitly representable value into a suitable optional.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01557">optional.h:1557</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01557">1557</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ab65621263872982e2ecf95bb2c190810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65621263872982e2ecf95bb2c190810">&#9670;&nbsp;</a></span>OPT_OR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPT_OR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_or_, (a).value)((a), (b))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects between two optional values based on whether the first optional is in the SOME state. </p>
<p>If the first argument is in the SOME state, returns the first optional. Otherwise returns the second optional. This macro can be used to provide a fallback optional value without actually unwrapping the value contained in the optional.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="structopt__float.html">opt_float</a> result = <a class="code" href="optional_8h.html#ab65621263872982e2ecf95bb2c190810">OPT_OR</a>(my_opt_float, fallback_opt_float);</div>
<div class="ttc" id="aoptional_8h_html_ab65621263872982e2ecf95bb2c190810"><div class="ttname"><a href="optional_8h.html#ab65621263872982e2ecf95bb2c190810">OPT_OR</a></div><div class="ttdeci">#define OPT_OR(a, b)</div><div class="ttdoc">Selects between two optional values based on whether the first optional is in the SOME state.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01418">optional.h:1418</a></div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The second argument to this macro is eagerly evaluated, even if the first argument is in the SOME state. You must take care to avoid unintended side effects of the second argument. If you want to force lazy execution, you must use the <a class="el" href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8" title="Selects between two optional values based on whether the first optional is in the SOME state....">OPT_OR_ELSE()</a> macro instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8" title="Selects between two optional values based on whether the first optional is in the SOME state....">OPT_OR_ELSE</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01418">1418</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a9a2271bdc73a0d537f55c0beefbd09b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2271bdc73a0d537f55c0beefbd09b8">&#9670;&nbsp;</a></span>OPT_OR_ELSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPT_OR_ELSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">func_b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg_b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_or_else_, (a).value)((a), (func_b), (arg_b))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects between two optional values based on whether the first optional is in the SOME state. Provides lazy evaluation. </p>
<p>If the <code>a</code> argument is in the SOME state, returns <code>a</code>. Otherwise calls <code>func_b</code> with argument <code>arg_b</code> and returns its return value. The <code>func_b</code> function must conform to this signature: </p><div class="fragment"><div class="line">opt_type func(<span class="keywordtype">void</span> *);</div>
</div><!-- fragment --><p> where <code>opt_type</code> is the same type as the type of <code>a</code>.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="structopt__float.html">opt_float</a> build_fallback(<span class="keywordtype">void</span> *arg);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="structopt__float.html">opt_float</a> result = <a class="code" href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8">OPT_OR_ELSE</a>(my_opt_float, build_fallback, foo);</div>
<div class="ttc" id="aoptional_8h_html_a9a2271bdc73a0d537f55c0beefbd09b8"><div class="ttname"><a href="optional_8h.html#a9a2271bdc73a0d537f55c0beefbd09b8">OPT_OR_ELSE</a></div><div class="ttdeci">#define OPT_OR_ELSE(a, func_b, arg_b)</div><div class="ttdoc">Selects between two optional values based on whether the first optional is in the SOME state....</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01454">optional.h:1454</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The purpose of this macro is to provide a mechanism for lazy evaluation of the fallback case. The <code>func_b</code> argument is not called unless the first argument is in the NONE state. If you want the second argument to be eagerly evaluated (as well as avoid having to write a callback function), use <a class="el" href="optional_8h.html#ab65621263872982e2ecf95bb2c190810" title="Selects between two optional values based on whether the first optional is in the SOME state.">OPT_OR()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#ab65621263872982e2ecf95bb2c190810" title="Selects between two optional values based on whether the first optional is in the SOME state.">OPT_OR</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01454">1454</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="af1bc079f415a97870a88de442562210f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bc079f415a97870a88de442562210f">&#9670;&nbsp;</a></span>OPTIONAL_TYPE_LIST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPTIONAL_TYPE_LIST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op_name</td><td>)</td>
          <td>&#160;&#160;&#160;    default: _unknown_optional_type_you_need_to_include_your_custom_optional_h_</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overridable list of custom optional types provided by your code. </p>
<p>If you want to specify a list of your own custom optional types, you must redefine this macro somewhere in your headers, to add the optional types using the <a class="el" href="optional_8h.html#a783fdd25c33e6bc7f19275548404e578" title="Appends a new entry to the definition of the OPTIONAL_TYPE_LIST() macro.">OPTIONAL_TYPE_LIST_ADD()</a> macro.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="preprocessor">#undef OPTIONAL_TYPE_LIST</span></div>
<div class="line"><span class="preprocessor">#define OPTIONAL_TYPE_LIST(op_name) \</span></div>
<div class="line"><span class="preprocessor">    OPTIONAL_TYPE_LIST_ADD(my_type_1, my_type_1, op_name), \</span></div>
<div class="line"><span class="preprocessor">    OPTIONAL_TYPE_LIST_ADD(my_type_2, my_type_2 *, op_name)</span></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#custom_opt_types">Adding Your Own Custom Optional Types</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00893">893</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a783fdd25c33e6bc7f19275548404e578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783fdd25c33e6bc7f19275548404e578">&#9670;&nbsp;</a></span>OPTIONAL_TYPE_LIST_ADD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPTIONAL_TYPE_LIST_ADD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c_type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op_name&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	c_type: op_name ## type_name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a new entry to the definition of the <a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f" title="Overridable list of custom optional types provided by your code.">OPTIONAL_TYPE_LIST()</a> macro. </p>
<p>Use this macro to append entries to your <a class="el" href="optional_8h.html#af1bc079f415a97870a88de442562210f" title="Overridable list of custom optional types provided by your code.">OPTIONAL_TYPE_LIST()</a> macro, which contains a list of your custom optional types.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#custom_opt_types">Adding Your Own Custom Optional Types</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00871">871</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ad37ae435f25f46c67993270d88bc219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37ae435f25f46c67993270d88bc219d">&#9670;&nbsp;</a></span>SOME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SOME</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td>&#160;&#160;&#160;OPTIONAL_TYPE_SELECTOR(opt_some_, expr)(expr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new optional value in the SOME state. </p>
<p>The type of the optional is determined by the result type of the expression in the <code>expr</code> argument.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="structopt__float.html">opt_float</a> my_func(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (some_condition()) {</div>
<div class="line">         <span class="keywordflow">return</span> <a class="code" href="optional_8h.html#ad37ae435f25f46c67993270d88bc219d">SOME</a>(5.0f);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">         <span class="keywordflow">return</span> <a class="code" href="optional_8h.html#a8a1dd117c8e0f7c9a98acd48235cd2f8">NONE</a>(<span class="keywordtype">float</span>);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Because the type is determined solely by the macro argument expression and not by the overall return type, you must make sure the expression is typed exactly to the desired optional type. This can require an explicit cast. For example <code>SOME(5.0)</code> always results in an <code><a class="el" href="structopt__double.html" title="An optional type for wrapping a non-NAN double value.">opt_double</a></code>, even if you want assign to or return an <code><a class="el" href="structopt__float.html" title="An optional type for wrapping a non-NAN float value.">opt_float</a></code>. To force the correct type inference, use <code>SOME(5.0f)</code> or <code>SOME((float)5.0)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>C++ doesn't support the C11 <code>_Generic</code> construct and thus automatic type inference cannot be used for the <code>SOME</code> macro. When used from C++ code, you must provide an explicit optional type name in the first argument, such as: <code>SOME(float, 5.0f)</code>. The optional type name is the latter part of the name of the optional type, e.g. for an <code><a class="el" href="structopt__str.html" title="An optional type for wrapping a non-NULL char * value.">opt_str</a></code> the type name is <code>str</code> and not necessarily the C type designator (which is <code>char *</code> in the case of <code><a class="el" href="structopt__str.html" title="An optional type for wrapping a non-NULL char * value.">opt_str</a></code>). </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00956">956</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a8a7d5589a8cfccfee83d6e1688eb9769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d5589a8cfccfee83d6e1688eb9769">&#9670;&nbsp;</a></span>UNWRAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    OPTIONAL_TYPE_SELECTOR(opt_unwrap_, (opt).value)((opt), \</div>
<div class="line">        <a class="code" href="log_8h.html#a02a8f73c9408ca73f31f9d97e872b150">log_basename</a>(__FILE__), __LINE__, #opt)</div>
<div class="ttc" id="alog_8h_html_a02a8f73c9408ca73f31f9d97e872b150"><div class="ttname"><a href="log_8h.html#a02a8f73c9408ca73f31f9d97e872b150">log_basename</a></div><div class="ttdeci">#define log_basename(f)</div><div class="ttdef"><b>Definition:</b> <a href="log_8h_source.html#l00089">log.h:89</a></div></div>
</div><!-- fragment -->
<p>Extracts the value of the optional unconditionally. </p>
<p>If the optional was in the SOME state, returns the wrapped value. If the optional was in the NONE state, causes a runtime assertion failure and panic. You should only use this macro during testing, or after you have made sure using other means that the optional is in the SOME state.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> my_value = <a class="code" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">UNWRAP</a>(my_opt_float);</div>
<div class="ttc" id="aoptional_8h_html_a8a7d5589a8cfccfee83d6e1688eb9769"><div class="ttname"><a href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">UNWRAP</a></div><div class="ttdeci">#define UNWRAP(opt)</div><div class="ttdoc">Extracts the value of the optional unconditionally.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01151">optional.h:1151</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01151">1151</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ae01ed771f70d85ff89606a591b79d2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01ed771f70d85ff89606a591b79d2aa">&#9670;&nbsp;</a></span>UNWRAP_AS_MUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_AS_MUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    OPTIONAL_TYPE_SELECTOR(opt_unwrap_as_mut_, (*(opt)).value)((opt), \</div>
<div class="line">        <a class="code" href="log_8h.html#a02a8f73c9408ca73f31f9d97e872b150">log_basename</a>(__FILE__), __LINE__, #opt)</div>
</div><!-- fragment -->
<p>Extracts a mutable reference to the value of the optional unconditionally. </p>
<p>If the optional was in the SOME state, returns a pointer to the wrapped value. If the optional was in the NONE state, causes a runtime assertion failure and panic. You should only use this macro during testing, or after you have made sure using other means that the optional is in the SOME state.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> *my_value_ref = <a class="code" href="optional_8h.html#ac3349fe30b9b3402f8be17056d4096a8">UNWRAP_AS_REF</a>(&amp;my_opt_float);</div>
<div class="ttc" id="aoptional_8h_html_ac3349fe30b9b3402f8be17056d4096a8"><div class="ttname"><a href="optional_8h.html#ac3349fe30b9b3402f8be17056d4096a8">UNWRAP_AS_REF</a></div><div class="ttdeci">#define UNWRAP_AS_REF(opt)</div><div class="ttdoc">Extracts an immutable reference to the value of the optional unconditionally.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01178">optional.h:1178</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01206">1206</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="ac3349fe30b9b3402f8be17056d4096a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3349fe30b9b3402f8be17056d4096a8">&#9670;&nbsp;</a></span>UNWRAP_AS_REF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_AS_REF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    OPTIONAL_TYPE_SELECTOR(opt_unwrap_as_ref_, (*(opt)).value)((opt), \</div>
<div class="line">        <a class="code" href="log_8h.html#a02a8f73c9408ca73f31f9d97e872b150">log_basename</a>(__FILE__), __LINE__, #opt)</div>
</div><!-- fragment -->
<p>Extracts an immutable reference to the value of the optional unconditionally. </p>
<p>If the optional was in the SOME state, returns a pointer to the wrapped value. If the optional was in the NONE state, causes a runtime assertion failure and panic. You should only use this macro during testing, or after you have made sure using other means that the optional is in the SOME state.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> *my_value_ref = <a class="code" href="optional_8h.html#ac3349fe30b9b3402f8be17056d4096a8">UNWRAP_AS_REF</a>(&amp;my_opt_float);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01178">1178</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a2f9cffa8e039ff076b435e897846a83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9cffa8e039ff076b435e897846a83d">&#9670;&nbsp;</a></span>UNWRAP_OR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_OR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dfl_value&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;	OPTIONAL_TYPE_SELECTOR(opt_unwrap_or_, (opt).value)((opt), (dfl_value))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the value of the optional, or evaluates to a fallback value. </p>
<p>If <code>opt</code> is in the SOME state, evaluates to the wrapped value. If <code>opt</code> is in the NONE state, evaluates to the <code>dfl_value</code> argument. This can be used to safely unwrap an optional, providing a default value in case the optional was in the NONE state.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> my_value = <a class="code" href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d">UNWRAP_OR</a>(my_opt_float, 0.0f);</div>
<div class="ttc" id="aoptional_8h_html_a2f9cffa8e039ff076b435e897846a83d"><div class="ttname"><a href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d">UNWRAP_OR</a></div><div class="ttdeci">#define UNWRAP_OR(opt, dfl_value)</div><div class="ttdoc">Extracts the value of the optional, or evaluates to a fallback value.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01238">optional.h:1238</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The second argument to this macro is eagerly evaluated, even if the first argument is in the SOME state. You must take care to avoid unintended side effects of the second argument. If you want to force lazy execution, you must use the <a class="el" href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e" title="Extracts the value of the optional, or yields a fallback value with lazy evaluation.">UNWRAP_OR_ELSE()</a> macro instead. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e" title="Extracts the value of the optional, or yields a fallback value with lazy evaluation.">UNWRAP_OR_ELSE()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01238">1238</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a35c9931829ced65af643eee46c5f89d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35c9931829ced65af643eee46c5f89d3">&#9670;&nbsp;</a></span>UNWRAP_OR_BREAK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_OR_BREAK</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ __typeof(opt) __tmp = (opt); \</div>
<div class="line">        if (<a class="code" href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536">IS_NONE</a>(__tmp)) { <span class="keywordflow">break</span>; } <a class="code" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">UNWRAP</a>(__tmp); })</div>
<div class="ttc" id="aoptional_8h_html_a1cab986d1f0da7498c0956df0e6c2536"><div class="ttname"><a href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536">IS_NONE</a></div><div class="ttdeci">#define IS_NONE(x)</div><div class="ttdoc">Returns true if the optional is in the NONE state.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01007">optional.h:1007</a></div></div>
</div><!-- fragment -->
<p>Unwraps a SOME value, or in case of a NONE value, breaks out of the current loop or switch case (invokes the <code>break</code> keyword). </p>
<p>This macro helps with flow control when a NONE variant is encountered.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// break out of loop if we get a NONE variant here</span></div>
<div class="line">    <span class="keywordtype">float</span> need_valid_value_here = <a class="code" href="optional_8h.html#a35c9931829ced65af643eee46c5f89d3">UNWRAP_OR_BREAK</a>(this_can_be_NONE());</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aoptional_8h_html_a35c9931829ced65af643eee46c5f89d3"><div class="ttname"><a href="optional_8h.html#a35c9931829ced65af643eee46c5f89d3">UNWRAP_OR_BREAK</a></div><div class="ttdeci">#define UNWRAP_OR_BREAK(opt)</div><div class="ttdoc">Unwraps a SOME value, or in case of a NONE value, breaks out of the current loop or switch case (invo...</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01366">optional.h:1366</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01366">1366</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a1ec726970abcfff30b1393958aa3768c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec726970abcfff30b1393958aa3768c">&#9670;&nbsp;</a></span>UNWRAP_OR_CONTINUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_OR_CONTINUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ __typeof(opt) __tmp = (opt); \</div>
<div class="line">        if (<a class="code" href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536">IS_NONE</a>(__tmp)) { <span class="keywordflow">continue</span>; } <a class="code" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">UNWRAP</a>(__tmp); })</div>
</div><!-- fragment -->
<p>Unwraps a SOME value, or in case of a NONE value, restarts the current loop iteration (invokes the <code>continue</code> keyword). </p>
<p>This macro helps with flow control when a NONE variant is encountered.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// continue to next loop iteration if we get a NONE variant here</span></div>
<div class="line">    <span class="keywordtype">float</span> need_valid_value_here = <a class="code" href="optional_8h.html#a1ec726970abcfff30b1393958aa3768c">UNWRAP_OR_CONTINUE</a>(this_can_be_NONE());</div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aoptional_8h_html_a1ec726970abcfff30b1393958aa3768c"><div class="ttname"><a href="optional_8h.html#a1ec726970abcfff30b1393958aa3768c">UNWRAP_OR_CONTINUE</a></div><div class="ttdeci">#define UNWRAP_OR_CONTINUE(opt)</div><div class="ttdoc">Unwraps a SOME value, or in case of a NONE value, restarts the current loop iteration (invokes the co...</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01389">optional.h:1389</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01389">1389</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="abdab34dccc16a52317b37db053d1db9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdab34dccc16a52317b37db053d1db9e">&#9670;&nbsp;</a></span>UNWRAP_OR_ELSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_OR_ELSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dfl_func, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dfl_arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    OPTIONAL_TYPE_SELECTOR(opt_unwrap_or_else_, (opt).value)\</div>
<div class="line">        ((opt), (dfl_func), (dfl_arg))</div>
</div><!-- fragment -->
<p>Extracts the value of the optional, or yields a fallback value with lazy evaluation. </p>
<p>If <code>opt</code> is in the SOME state, evaluates to the wrapped value. If <code>opt</code> is in the NONE state, calls <code>dfl_func</code> with <code>dfl_arg</code> in its argument and evaluates to the return value of this call. The function must have a signature conforming to: </p><div class="fragment"><div class="line">c_type func(<span class="keywordtype">void</span> *);</div>
</div><!-- fragment --><p> where <code>c_type</code> is the native C type wrapped in the optional type. This can be used to safely unwrap an optional, providing a lazily evaluated default value in case the optional was in the NONE state.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> calc_fallback(<span class="keywordtype">void</span> *arg);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">float</span> my_value = <a class="code" href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e">UNWRAP_OR_ELSE</a>(my_opt_float, calc_fallback, foo);</div>
<div class="ttc" id="aoptional_8h_html_abdab34dccc16a52317b37db053d1db9e"><div class="ttname"><a href="optional_8h.html#abdab34dccc16a52317b37db053d1db9e">UNWRAP_OR_ELSE</a></div><div class="ttdeci">#define UNWRAP_OR_ELSE(opt, dfl_func, dfl_arg)</div><div class="ttdoc">Extracts the value of the optional, or yields a fallback value with lazy evaluation.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01277">optional.h:1277</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>The purpose of this macro is to provide a mechanism for lazy evaluation of the default case. The function is not called unless the first argument is in the NONE state. If you want the second argument to be eagerly evaluated (as well as avoid having to write a callback function), use <a class="el" href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d" title="Extracts the value of the optional, or evaluates to a fallback value.">UNWRAP_OR()</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="optional_8h.html#a2f9cffa8e039ff076b435e897846a83d" title="Extracts the value of the optional, or evaluates to a fallback value.">UNWRAP_OR()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01277">1277</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a0b7b9cfb51a5a99a436e2b7931bda182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7b9cfb51a5a99a436e2b7931bda182">&#9670;&nbsp;</a></span>UNWRAP_OR_GOTO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_OR_GOTO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">label&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ __typeof(opt) __tmp = (opt); \</div>
<div class="line">        if (<a class="code" href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536">IS_NONE</a>(__tmp)) { <span class="keywordflow">goto</span> label; } <a class="code" href="optional_8h.html#a8a7d5589a8cfccfee83d6e1688eb9769">UNWRAP</a>(__tmp); })</div>
</div><!-- fragment -->
<p>Unwraps a SOME value, or in case of a NONE value, goes to the label. </p>
<p>This macro helps with unwinding when a NONE variant is encountered, requiring cleanup of the current function.</p>
<p>Example usage: </p><div class="fragment"><div class="line"><a class="code" href="structopt__float.html">opt_float</a> foo(<span class="keywordtype">void</span>);    <span class="comment">// can return NONE variant</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bar() {</div>
<div class="line">    <span class="comment">// setup some resources that need cleanup</span></div>
<div class="line">    ...</div>
<div class="line">    <span class="keywordtype">float</span> need_valid_value_here = <a class="code" href="optional_8h.html#a0b7b9cfb51a5a99a436e2b7931bda182">UNWRAP_OR_GOTO</a>(foo(), out);</div>
<div class="line">    ...</div>
<div class="line">    <span class="comment">// use need_valid_value_here</span></div>
<div class="line">    ...</div>
<div class="line">out:</div>
<div class="line">    <span class="comment">// perform cleanup of resources acquired during setup</span></div>
<div class="line">}</div>
<div class="ttc" id="aoptional_8h_html_a0b7b9cfb51a5a99a436e2b7931bda182"><div class="ttname"><a href="optional_8h.html#a0b7b9cfb51a5a99a436e2b7931bda182">UNWRAP_OR_GOTO</a></div><div class="ttdeci">#define UNWRAP_OR_GOTO(opt, label)</div><div class="ttdoc">Unwraps a SOME value, or in case of a NONE value, goes to the label.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01343">optional.h:1343</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01343">1343</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<a id="a4ed10e38616c95b04336c8af536addc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed10e38616c95b04336c8af536addc2">&#9670;&nbsp;</a></span>UNWRAP_OR_RET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNWRAP_OR_RET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">opt, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ({ __typeof(opt) __tmp = (opt); \</div>
<div class="line">        if (<a class="code" href="optional_8h.html#a1cab986d1f0da7498c0956df0e6c2536">IS_NONE</a>(__tmp)) { <span class="keywordflow">return</span> __VA_ARGS__; } \</div>
<div class="line">        UNWRAP(__tmp); })</div>
</div><!-- fragment -->
<p>Unwraps a SOME value, or in case of a NONE value, returns from the current function. </p>
<p>This macro lets you emulate the Rust '?' operator.</p><ol type="1">
<li>If the first argument is in the SOME state, the contained value is yielded.</li>
<li>If the first argument is in the NONE state, returns from the current function, optionally with a return value of your choosing.</li>
</ol>
<p>The way to use this macro is as follows: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> my_func(<a class="code" href="structopt__float.html">opt_float</a> wrapped_value) {</div>
<div class="line">    <span class="comment">// if `wrapped_value` is NONE, we return from `my_func` with `false`:</span></div>
<div class="line">    <span class="keywordtype">float</span> value = <a class="code" href="optional_8h.html#a4ed10e38616c95b04336c8af536addc2">UNWRAP_OR_RET</a>(wrapped_value, <span class="keyword">false</span>);</div>
<div class="line">    <span class="comment">// ... do something with `value`, it is guaranteed to be valid ...</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aoptional_8h_html_a4ed10e38616c95b04336c8af536addc2"><div class="ttname"><a href="optional_8h.html#a4ed10e38616c95b04336c8af536addc2">UNWRAP_OR_RET</a></div><div class="ttdeci">#define UNWRAP_OR_RET(opt,...)</div><div class="ttdoc">Unwraps a SOME value, or in case of a NONE value, returns from the current function.</div><div class="ttdef"><b>Definition:</b> <a href="optional_8h_source.html#l01313">optional.h:1313</a></div></div>
</div><!-- fragment --><p> To return with no value from the current function, simply invoke the macro with just one argument: </p><div class="fragment"><div class="line"><span class="keywordtype">float</span> foo = <a class="code" href="optional_8h.html#a4ed10e38616c95b04336c8af536addc2">UNWRAP_OR_RET</a>(wrapped_foo);</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l01313">1313</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="addfb05740c0220faaea7030f0111965e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfb05740c0220faaea7030f0111965e">&#9670;&nbsp;</a></span>optional_state_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="optional_8h.html#addfb05740c0220faaea7030f0111965e">optional_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describes the state of an optional type. This enumeration is returned by the <a class="el" href="optional_8h.html#ace2138afa1ae8fb5f0e9127f90098469" title="Extracts the value embedded in the optional and returns the optional_state_t enum corresponding to th...">MATCH()</a> macro. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="addfb05740c0220faaea7030f0111965ea2ed357c9466d276e4ed1141e49f2f530"></a>OPT_NONE&#160;</td><td class="fielddoc"><p>State denoting that the optional contains no valid value. </p>
</td></tr>
<tr><td class="fieldname"><a id="addfb05740c0220faaea7030f0111965ea09a1ad2f8ced7d15945c07ccb267b04f"></a>OPT_SOME&#160;</td><td class="fielddoc"><p>State denoting that the optional contains a valid value. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="optional_8h_source.html#l00273">273</a> of file <a class="el" href="optional_8h_source.html">optional.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
