<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libacfutils: acfutils/thread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libacfutils
   </div>
   <div id="projectbrief">A general purpose library of utility functions designed to make it easier to develop addons for the X-Plane flight simulator.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2f18166f86af4fcbeaddefb60d5355e9.html">acfutils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">thread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;errno.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;windows.h&gt;</code><br />
<code>#include &quot;<a class="el" href="assert_8h_source.html">assert.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="helpers_8h_source.html">helpers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="list_8h_source.html">list.h</a>&quot;</code><br />
<code>#include &quot;time.h&quot;</code><br />
<code>#include &quot;<a class="el" href="safe__alloc_8h_source.html">safe_alloc.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for thread.h:</div>
<div class="dyncontent">
<div class="center"><img src="thread_8h__incl.png" border="0" usemap="#aacfutils_2thread_8h" alt=""/></div>
<map name="aacfutils_2thread_8h" id="aacfutils_2thread_8h">
<area shape="rect" title=" " alt="" coords="492,5,620,32"/>
<area shape="rect" title=" " alt="" coords="233,304,301,331"/>
<area shape="rect" title=" " alt="" coords="1329,80,1404,107"/>
<area shape="rect" title=" " alt="" coords="439,677,510,704"/>
<area shape="rect" title=" " alt="" coords="1110,304,1181,331"/>
<area shape="rect" title=" " alt="" coords="1428,80,1519,107"/>
<area shape="rect" href="assert_8h.html" title=" " alt="" coords="325,304,400,331"/>
<area shape="rect" href="helpers_8h.html" title=" " alt="" coords="591,80,673,107"/>
<area shape="rect" href="safe__alloc_8h.html" title=" " alt="" coords="625,229,725,256"/>
<area shape="rect" href="time_8h_source.html" title=" " alt="" coords="93,229,157,256"/>
<area shape="rect" href="list_8h.html" title=" " alt="" coords="1250,80,1305,107"/>
<area shape="rect" href="log_8h.html" title=" " alt="" coords="281,379,335,405"/>
<area shape="rect" href="sysmacros_8h.html" title=" " alt="" coords="541,453,645,480"/>
<area shape="rect" title=" " alt="" coords="144,453,219,480"/>
<area shape="rect" title=" " alt="" coords="243,453,365,480"/>
<area shape="rect" href="types_8h_source.html" title=" " alt="" coords="550,528,621,555"/>
<area shape="rect" title=" " alt="" coords="169,603,239,629"/>
<area shape="rect" title=" " alt="" coords="550,603,621,629"/>
<area shape="rect" href="core_8h.html" title=" " alt="" coords="721,603,783,629"/>
<area shape="rect" href="libconfig_8h_source.html" title=" " alt="" coords="707,677,797,704"/>
<area shape="rect" title=" " alt="" coords="937,229,1007,256"/>
<area shape="rect" title=" " alt="" coords="695,155,761,181"/>
<area shape="rect" title=" " alt="" coords="1272,229,1368,256"/>
<area shape="rect" href="math_8h.html" title=" " alt="" coords="349,155,417,181"/>
<area shape="rect" href="math__core_8h.html" title=" " alt="" coords="433,229,535,256"/>
<area shape="rect" href="lacf__getline__impl_8h.html" title=" " alt="" coords="785,155,932,181"/>
<area shape="rect" href="parser__funcs_8h.html" title=" " alt="" coords="1007,155,1124,181"/>
<area shape="rect" href="geom_8h.html" title=" " alt="" coords="465,379,535,405"/>
<area shape="rect" href="list__impl_8h.html" title=" " alt="" coords="1300,155,1391,181"/>
</map>
</div>
</div>
<p><a href="thread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlacf__thread__info__t.html">lacf_thread_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmutex__t.html">mutex_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrwmutex__t.html">rwmutex_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrwlock__waiter__t.html">rwlock_waiter_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af786b659a08ce46cf82d1ff34e850117"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create</a>(thrp,  start_proc,  arg)</td></tr>
<tr class="separator:af786b659a08ce46cf82d1ff34e850117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76001c2c78446302a9aa4ad103d74116"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a76001c2c78446302a9aa4ad103d74116">atomic32_t</a>&#160;&#160;&#160;volatile int32_t</td></tr>
<tr class="separator:a76001c2c78446302a9aa4ad103d74116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b5e21091a75e0e75cfca49c7f01598"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa3b5e21091a75e0e75cfca49c7f01598">atomic_inc_32</a>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td></tr>
<tr class="separator:aa3b5e21091a75e0e75cfca49c7f01598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b7a2b69f112515950641b4e656dfa9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a21b7a2b69f112515950641b4e656dfa9">atomic_dec_32</a>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), -1)</td></tr>
<tr class="separator:a21b7a2b69f112515950641b4e656dfa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853b82617fd36250fb02c111dacd8641"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a853b82617fd36250fb02c111dacd8641">atomic_add_32</a>(x,  y)&#160;&#160;&#160;__sync_add_and_fetch((x), (y))</td></tr>
<tr class="separator:a853b82617fd36250fb02c111dacd8641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49900de1ae7bda860e67a808129e589"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad49900de1ae7bda860e67a808129e589">atomic_set_32</a>(x,  y)&#160;&#160;&#160;__atomic_store_n((x), (y), __ATOMIC_RELAXED)</td></tr>
<tr class="separator:ad49900de1ae7bda860e67a808129e589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa556f1df2e602b1dc318dced31d9b7df"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aa556f1df2e602b1dc318dced31d9b7df">atomic64_t</a>&#160;&#160;&#160;volatile int64_t</td></tr>
<tr class="separator:aa556f1df2e602b1dc318dced31d9b7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe103fb4cb042d1c0754af99bd7d2c99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#afe103fb4cb042d1c0754af99bd7d2c99">atomic_inc_64</a>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td></tr>
<tr class="separator:afe103fb4cb042d1c0754af99bd7d2c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d765d86950dcff9fb10fcd6b0a5527c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4d765d86950dcff9fb10fcd6b0a5527c">atomic_dec_64</a>(x)&#160;&#160;&#160;__sync_add_and_fetch((x), -1)</td></tr>
<tr class="separator:a4d765d86950dcff9fb10fcd6b0a5527c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe595a4cd13046f1241a36c6e43d668"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aefe595a4cd13046f1241a36c6e43d668">atomic_add_64</a>(x,  y)&#160;&#160;&#160;__sync_add_and_fetch((x), (y))</td></tr>
<tr class="separator:aefe595a4cd13046f1241a36c6e43d668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6851805657330c5c775a7051c93c876c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6851805657330c5c775a7051c93c876c">atomic_set_64</a>(x,  y)&#160;&#160;&#160;__atomic_store_n((x), (y), __ATOMIC_RELAXED)</td></tr>
<tr class="separator:a6851805657330c5c775a7051c93c876c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833ceaa5cf7a525bbd4f96f7fac6e223"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a833ceaa5cf7a525bbd4f96f7fac6e223">curthread_id</a>&#160;&#160;&#160;GetCurrentThreadId()</td></tr>
<tr class="separator:a833ceaa5cf7a525bbd4f96f7fac6e223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9686d1e1b5e62a2ccbab471d8cccf64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac9686d1e1b5e62a2ccbab471d8cccf64">curthread</a>&#160;&#160;&#160;GetCurrentThread()</td></tr>
<tr class="separator:ac9686d1e1b5e62a2ccbab471d8cccf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2bdfd27350761a2f07e6069f834ee2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6b2bdfd27350761a2f07e6069f834ee2">VERIFY_MUTEX_HELD</a>(mtx)&#160;&#160;&#160;(void)1</td></tr>
<tr class="separator:a6b2bdfd27350761a2f07e6069f834ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63952d5e98e5fac2e1097cda30d65639"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a63952d5e98e5fac2e1097cda30d65639">VERIFY_MUTEX_NOT_HELD</a>(mtx)&#160;&#160;&#160;(void)1</td></tr>
<tr class="separator:a63952d5e98e5fac2e1097cda30d65639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa96aa6ed8947042ae9719a4e4d1b15b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aaa96aa6ed8947042ae9719a4e4d1b15b">THREAD_PRIO_IDLE</a>&#160;&#160;&#160;THREAD_PRIORITY_IDLE</td></tr>
<tr class="separator:aaa96aa6ed8947042ae9719a4e4d1b15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246fc75269629a2471226f2c764b2148"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a246fc75269629a2471226f2c764b2148">THREAD_PRIO_VERY_LOW</a>&#160;&#160;&#160;THREAD_PRIORITY_LOWEST</td></tr>
<tr class="separator:a246fc75269629a2471226f2c764b2148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b96cd9efa7d5c0c433780a05ccac7fc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a4b96cd9efa7d5c0c433780a05ccac7fc">THREAD_PRIO_LOW</a>&#160;&#160;&#160;THREAD_PRIORITY_BELOW_NORMAL</td></tr>
<tr class="separator:a4b96cd9efa7d5c0c433780a05ccac7fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581bd0febc37209e1d144ab6b5cc971c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a581bd0febc37209e1d144ab6b5cc971c">THREAD_PRIO_NORM</a>&#160;&#160;&#160;THREAD_PRIORITY_NORMAL</td></tr>
<tr class="separator:a581bd0febc37209e1d144ab6b5cc971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e837a74202b264cd0811fd1978ceb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad8e837a74202b264cd0811fd1978ceb2">THREAD_PRIO_HIGH</a>&#160;&#160;&#160;THREAD_PRIORITY_ABOVE_NORMAL</td></tr>
<tr class="separator:ad8e837a74202b264cd0811fd1978ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3150d44c8e6f8cd82b5ee31c405177f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af3150d44c8e6f8cd82b5ee31c405177f">THREAD_PRIO_VERY_HIGH</a>&#160;&#160;&#160;THREAD_PRIORITY_HIGHEST</td></tr>
<tr class="separator:af3150d44c8e6f8cd82b5ee31c405177f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35851b93293217dcfd7f0c742f7fe419"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a35851b93293217dcfd7f0c742f7fe419">THREAD_PRIO_RT</a>&#160;&#160;&#160;THREAD_PRIORITY_TIME_CRITICAL</td></tr>
<tr class="separator:a35851b93293217dcfd7f0c742f7fe419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e863e9ba8b50eafe4f2b3d23bcbe7c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5e863e9ba8b50eafe4f2b3d23bcbe7c0">ASSERT_MUTEX_HELD</a>(mtx)</td></tr>
<tr class="separator:a5e863e9ba8b50eafe4f2b3d23bcbe7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2be31cac0a52c8d012ce5e6f387a2e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad2be31cac0a52c8d012ce5e6f387a2e2">ASSERT_MUTEX_NOT_HELD</a>(mtx)</td></tr>
<tr class="separator:ad2be31cac0a52c8d012ce5e6f387a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab473f076e05d966f00b78ecb88c8f357"><td class="memItemLeft" align="right" valign="top">typedef HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a></td></tr>
<tr class="separator:ab473f076e05d966f00b78ecb88c8f357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1cbe064d0b759f6e73df45d51488be"><td class="memItemLeft" align="right" valign="top">typedef DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9a1cbe064d0b759f6e73df45d51488be">thread_id_t</a></td></tr>
<tr class="separator:a9a1cbe064d0b759f6e73df45d51488be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab38838d7ef7332e8cced210141e72c"><td class="memItemLeft" align="right" valign="top">typedef CONDITION_VARIABLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a></td></tr>
<tr class="separator:a0ab38838d7ef7332e8cced210141e72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8c472da748aed9d5a2214284bf704475"><td class="memItemLeft" align="right" valign="top"><a id="a8c472da748aed9d5a2214284bf704475"></a>
static bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>thread_equal</b> (<a class="el" href="thread_8h.html#a9a1cbe064d0b759f6e73df45d51488be">thread_id_t</a> tid1, <a class="el" href="thread_8h.html#a9a1cbe064d0b759f6e73df45d51488be">thread_id_t</a> tid2)</td></tr>
<tr class="separator:a8c472da748aed9d5a2214284bf704475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad740bab5dd6dd968f1b026c4b3cbc826"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *mtx)</td></tr>
<tr class="separator:ad740bab5dd6dd968f1b026c4b3cbc826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786e2308c77efa9600eaa81522c1ab32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a786e2308c77efa9600eaa81522c1ab32">mutex_destroy</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *mtx)</td></tr>
<tr class="separator:a786e2308c77efa9600eaa81522c1ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7c57534b154632f3ee43b3af22abe2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *mtx)</td></tr>
<tr class="separator:a7c7c57534b154632f3ee43b3af22abe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9147646b7eef9f977404c4192340442f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a> (<a class="el" href="structmutex__t.html">mutex_t</a> *mtx)</td></tr>
<tr class="separator:a9147646b7eef9f977404c4192340442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba58bd39057ba648bec290cb12d58de8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aba58bd39057ba648bec290cb12d58de8">_lacf_thread_list_init</a> (void)</td></tr>
<tr class="separator:aba58bd39057ba648bec290cb12d58de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583893e587676d684012464f6f33508f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a583893e587676d684012464f6f33508f">_lacf_thread_list_fini</a> (void)</td></tr>
<tr class="separator:a583893e587676d684012464f6f33508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73a11b7cc2311ca25c66a78e3945dd3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac73a11b7cc2311ca25c66a78e3945dd3">_lacf_thread_list_add</a> (<a class="el" href="structlacf__thread__info__t.html">lacf_thread_info_t</a> *ti)</td></tr>
<tr class="separator:ac73a11b7cc2311ca25c66a78e3945dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee84e92c0685431cf140a4cbf10842cf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aee84e92c0685431cf140a4cbf10842cf">_lacf_thread_list_remove</a> (<a class="el" href="structlacf__thread__info__t.html">lacf_thread_info_t</a> *ti)</td></tr>
<tr class="separator:aee84e92c0685431cf140a4cbf10842cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc8471978120bbf92d4560bf1496103"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#aedc8471978120bbf92d4560bf1496103">lacf_threads_fini</a> (void)</td></tr>
<tr class="separator:aedc8471978120bbf92d4560bf1496103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0c67fc8f2d8d8eb9528a65ae109ad2"><td class="memItemLeft" align="right" valign="top">DWORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5a0c67fc8f2d8d8eb9528a65ae109ad2">lacf_thread_start_routine</a> (void *arg)</td></tr>
<tr class="separator:a5a0c67fc8f2d8d8eb9528a65ae109ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b5159e92fa0e7f699717c49777508d"><td class="memItemLeft" align="right" valign="top">static bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a39b5159e92fa0e7f699717c49777508d">lacf_thread_create</a> (<a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> *thrp, void(*proc)(void *), void *arg, const char *filename, int linenum)</td></tr>
<tr class="separator:a39b5159e92fa0e7f699717c49777508d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a65ac5862e099f0e7812957d43a3a1c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a7a65ac5862e099f0e7812957d43a3a1c">thread_join</a> (<a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> *thrp)</td></tr>
<tr class="separator:a7a65ac5862e099f0e7812957d43a3a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eed8148cb94fb7395f4c342e4e365f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6eed8148cb94fb7395f4c342e4e365f1">thread_set_name</a> (const char *name)</td></tr>
<tr class="separator:a6eed8148cb94fb7395f4c342e4e365f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61a866c66b3a177a5ef1b31f1fc7ed1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait</a> (<a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *cv, <a class="el" href="structmutex__t.html">mutex_t</a> *mtx)</td></tr>
<tr class="separator:ab61a866c66b3a177a5ef1b31f1fc7ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef27d2f99d996e8b84a85bd43cfd5de"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait</a> (<a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *cv, <a class="el" href="structmutex__t.html">mutex_t</a> *mtx, uint64_t limit)</td></tr>
<tr class="separator:acef27d2f99d996e8b84a85bd43cfd5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827d83b9b8c009b1f2c791b88190fdfd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init</a> (<a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *cv)</td></tr>
<tr class="separator:a827d83b9b8c009b1f2c791b88190fdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd9f72f221894bb9440aee0ed4c0990"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5dd9f72f221894bb9440aee0ed4c0990">cv_destroy</a> (<a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *cv)</td></tr>
<tr class="separator:a5dd9f72f221894bb9440aee0ed4c0990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cfce39bd9db07016198e6d4fe17f60"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac6cfce39bd9db07016198e6d4fe17f60">cv_signal</a> (<a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *cv)</td></tr>
<tr class="separator:ac6cfce39bd9db07016198e6d4fe17f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae146473511da0640f3292e7b0b43d1a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ae146473511da0640f3292e7b0b43d1a6">cv_broadcast</a> (<a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *cv)</td></tr>
<tr class="separator:ae146473511da0640f3292e7b0b43d1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e58cfdef7cfba56460fd162302fee0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio</a> (<a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> thr, int prio)</td></tr>
<tr class="separator:a70e58cfdef7cfba56460fd162302fee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac09aa4ddc1c4f0c22ee44d80dd19c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a6ac09aa4ddc1c4f0c22ee44d80dd19c7">lacf_mask_sigpipe</a> (void)</td></tr>
<tr class="separator:a6ac09aa4ddc1c4f0c22ee44d80dd19c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377021479ab80f7873fd382ae111222d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a377021479ab80f7873fd382ae111222d">rwmutex_init</a> (<a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw)</td></tr>
<tr class="separator:a377021479ab80f7873fd382ae111222d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf1a60ece7f1aaa11c711c304f678fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a5bf1a60ece7f1aaa11c711c304f678fd">rwmutex_destroy</a> (<a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw)</td></tr>
<tr class="separator:a5bf1a60ece7f1aaa11c711c304f678fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54461f822e127a882d6b144abcd9e1b"><td class="memItemLeft" align="right" valign="top">static bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ab54461f822e127a882d6b144abcd9e1b">rwmutex_held_write</a> (<a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw)</td></tr>
<tr class="separator:ab54461f822e127a882d6b144abcd9e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9445f660555e36865aeb606c614e2aba"><td class="memItemLeft" align="right" valign="top">static bool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a9445f660555e36865aeb606c614e2aba">rwmutex_can_enter_impl</a> (const <a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw, const <a class="el" href="structrwlock__waiter__t.html">rwlock_waiter_t</a> *wt_self)</td></tr>
<tr class="separator:a9445f660555e36865aeb606c614e2aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eb36ceb0203220867021ceac4bc2ef"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#a32eb36ceb0203220867021ceac4bc2ef">rwmutex_enter</a> (<a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw, bool_t write)</td></tr>
<tr class="separator:a32eb36ceb0203220867021ceac4bc2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83275c541a5fd2a13ecce03457e59ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#ac83275c541a5fd2a13ecce03457e59ca">rwmutex_exit</a> (<a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw)</td></tr>
<tr class="separator:ac83275c541a5fd2a13ecce03457e59ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25b7a9564357bc92b2f89902ca175f1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8h.html#af25b7a9564357bc92b2f89902ca175f1">rwmutex_upgrade</a> (<a class="el" href="structrwmutex__t.html">rwmutex_t</a> *rw)</td></tr>
<tr class="separator:af25b7a9564357bc92b2f89902ca175f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6ab0e225e148512d54c1a9229ed8193a"><td class="memItemLeft" align="right" valign="top"><a id="a6ab0e225e148512d54c1a9229ed8193a"></a>
bool_t&#160;</td><td class="memItemRight" valign="bottom"><b>lacf_thread_list_inited</b></td></tr>
<tr class="separator:a6ab0e225e148512d54c1a9229ed8193a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c8e1865b3edc2189c95dbaa5838b0c"><td class="memItemLeft" align="right" valign="top"><a id="a36c8e1865b3edc2189c95dbaa5838b0c"></a>
<a class="el" href="structmutex__t.html">mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lacf_thread_list_lock</b></td></tr>
<tr class="separator:a36c8e1865b3edc2189c95dbaa5838b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa962b3a8907bd67940b4cde4f16ff540"><td class="memItemLeft" align="right" valign="top"><a id="aa962b3a8907bd67940b4cde4f16ff540"></a>
<a class="el" href="structlist__t.html">list_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lacf_thread_list</b></td></tr>
<tr class="separator:aa962b3a8907bd67940b4cde4f16ff540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Basic portable multi-threading API. We have 3 kinds of objects and associated manipulation functions here:</p><ol type="1">
<li><a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> - A generic thread identification structure.</li>
<li><a class="el" href="structmutex__t.html">mutex_t</a> - A generic mutual exclusion lock.</li>
<li><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> - A generic condition variable.</li>
</ol>
<p>The actual implementation is large contained in this header and mostly works as a set of pre-processor switching on top of the OS-specific threading API (pthreads on Unix/Linux, winthreads on Win32).</p>
<h2><a class="anchor" id="autotoc_md10"></a>
Thread Handling</h2>
<p>Example of how to create a thread: </p><div class="fragment"><div class="line"><a class="code" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> my_thread;</div>
<div class="line"><span class="keywordflow">if</span> (!<a class="code" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create</a>(&amp;my_thread, thread_main_func, thread_arg))</div>
<div class="line">    fprintf(stderr, <span class="stringliteral">&quot;thread create failed!\n&quot;</span>);</div>
<div class="ttc" id="athread_8h_html_ab473f076e05d966f00b78ecb88c8f357"><div class="ttname"><a href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a></div><div class="ttdeci">HANDLE thread_t</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00393">thread.h:393</a></div></div>
<div class="ttc" id="athread_8h_html_af786b659a08ce46cf82d1ff34e850117"><div class="ttname"><a href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create</a></div><div class="ttdeci">#define thread_create(thrp, start_proc, arg)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00189">thread.h:189</a></div></div>
</div><!-- fragment --><p> Example of how to wait for a thread to exit: </p><div class="fragment"><div class="line">   <a class="code" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> my_thread;</div>
<div class="line">   <a class="code" href="thread_8h.html#a7a65ac5862e099f0e7812957d43a3a1c">thread_join</a>(my_thread);</div>
<div class="line">   <span class="comment">// ... thread disposed of, no need for further cleanup ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">## Locking</span></div>
<div class="ttc" id="athread_8h_html_a7a65ac5862e099f0e7812957d43a3a1c"><div class="ttname"><a href="thread_8h.html#a7a65ac5862e099f0e7812957d43a3a1c">thread_join</a></div><div class="ttdeci">static void thread_join(thread_t *thrp)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00836">thread.h:836</a></div></div>
</div><!-- fragment --><p> Example of how to use a <a class="el" href="structmutex__t.html">mutex_t</a>: </p><div class="fragment"><div class="line">   <a class="code" href="structmutex__t.html">mutex_t</a> my_lock;                <span class="comment">// the lock object itself</span></div>
<div class="line">   <a class="code" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init</a>(&amp;my_lock);           <span class="comment">// create the lock</span></div>
<div class="line">   <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(&amp;my_lock);          <span class="comment">// grab the lock</span></div>
<div class="line">   <span class="comment">// ... do some critical, exclusiony-type stuff ...</span></div>
<div class="line">   <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(&amp;my_lock);           <span class="comment">// release the lock</span></div>
<div class="line">   <a class="code" href="thread_8h.html#a786e2308c77efa9600eaa81522c1ab32">mutex_destroy</a>(&amp;my_lock);        <span class="comment">// free the lock</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">## Condition Variables</span></div>
<div class="ttc" id="astructmutex__t_html"><div class="ttname"><a href="structmutex__t.html">mutex_t</a></div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00413">thread.h:413</a></div></div>
<div class="ttc" id="athread_8h_html_a786e2308c77efa9600eaa81522c1ab32"><div class="ttname"><a href="thread_8h.html#a786e2308c77efa9600eaa81522c1ab32">mutex_destroy</a></div><div class="ttdeci">static void mutex_destroy(mutex_t *mtx)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00499">thread.h:499</a></div></div>
<div class="ttc" id="athread_8h_html_a7c7c57534b154632f3ee43b3af22abe2"><div class="ttname"><a href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a></div><div class="ttdeci">static void mutex_enter(mutex_t *mtx)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00530">thread.h:530</a></div></div>
<div class="ttc" id="athread_8h_html_a9147646b7eef9f977404c4192340442f"><div class="ttname"><a href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a></div><div class="ttdeci">static void mutex_exit(mutex_t *mtx)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00556">thread.h:556</a></div></div>
<div class="ttc" id="athread_8h_html_ad740bab5dd6dd968f1b026c4b3cbc826"><div class="ttname"><a href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init</a></div><div class="ttdeci">static void mutex_init(mutex_t *mtx)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00488">thread.h:488</a></div></div>
</div><!-- fragment --><p> Example of how to use a condvar_t: </p><div class="fragment"><div class="line"><a class="code" href="structmutex__t.html">mutex_t</a> my_lock;</div>
<div class="line"><a class="code" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> my_cv;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init</a>(&amp;my_lock);       <span class="comment">// create a lock to control the CV</span></div>
<div class="line"><a class="code" href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init</a>(&amp;my_cv);        <span class="comment">// create the condition variable</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// thread that&#39;s going to signal the condition:</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(&amp;my_lock);  <span class="comment">// grab the lock</span></div>
<div class="line">    <span class="comment">// ... set up some resource that others might be waiting on ...</span></div>
<div class="line">    <a class="code" href="thread_8h.html#ae146473511da0640f3292e7b0b43d1a6">cv_broadcast</a>(&amp;my_lock); <span class="comment">// wake up all waiters</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(&amp;my_lock);   <span class="comment">// release the lock</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// thread that&#39;s going to wait on the condition:</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(&amp;my_lock);          <span class="comment">// grab the lock</span></div>
<div class="line">    <span class="keywordflow">while</span> (!condition_met())</div>
<div class="line">        <a class="code" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait</a>(&amp;my_cv, &amp;my_lock);  <span class="comment">// wait for the CV</span></div>
<div class="line">                        <span class="comment">// to be signalled</span></div>
<div class="line">    <span class="comment">// ... condition fulfilled, use the resource ...</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(&amp;my_lock);           <span class="comment">// release the lock</span></div>
<div class="ttc" id="athread_8h_html_a0ab38838d7ef7332e8cced210141e72c"><div class="ttname"><a href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a></div><div class="ttdeci">CONDITION_VARIABLE condvar_t</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00465">thread.h:465</a></div></div>
<div class="ttc" id="athread_8h_html_a827d83b9b8c009b1f2c791b88190fdfd"><div class="ttname"><a href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init</a></div><div class="ttdeci">static void cv_init(condvar_t *cv)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00926">thread.h:926</a></div></div>
<div class="ttc" id="athread_8h_html_ab61a866c66b3a177a5ef1b31f1fc7ed1"><div class="ttname"><a href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait</a></div><div class="ttdeci">static void cv_wait(condvar_t *cv, mutex_t *mtx)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00868">thread.h:868</a></div></div>
<div class="ttc" id="athread_8h_html_ae146473511da0640f3292e7b0b43d1a6"><div class="ttname"><a href="thread_8h.html#ae146473511da0640f3292e7b0b43d1a6">cv_broadcast</a></div><div class="ttdeci">static void cv_broadcast(condvar_t *cv)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00960">thread.h:960</a></div></div>
</div><!-- fragment --><p> You can also performed a "timed" wait on a CV using <a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a>. The function will exit when either the condition has been signalled, or the timer has expired. The return value of the function indicates whether the condition was signalled before the timer expired (returns zero), or if the wait timed out (returns ETIMEDOUT) or another error occurred (returns -1). </p><div class="fragment"><div class="line"><a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(&amp;my_lock);          <span class="comment">// grab the lock</span></div>
<div class="line"><span class="comment">// Wait for the CV to be signalled. Time argument is an</span></div>
<div class="line"><span class="comment">// absolute time as returned by the &#39;microclock&#39; function +</span></div>
<div class="line"><span class="comment">// whatever extra time delay you want to apply.</span></div>
<div class="line">uint64_t deadline = microclock() + timeout_usecs;</div>
<div class="line"><span class="keywordflow">while</span> (!condition_met()) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait</a>(&amp;my_cv, &amp;my_lock, deadline) ==</div>
<div class="line">        ETIMEDOUT) {</div>
<div class="line">        <span class="comment">// timed out waiting for CV to signal</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"><a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(&amp;my_lock);           <span class="comment">// release the lock</span></div>
<div class="ttc" id="athread_8h_html_acef27d2f99d996e8b84a85bd43cfd5de"><div class="ttname"><a href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait</a></div><div class="ttdeci">static int cv_timedwait(condvar_t *cv, mutex_t *mtx, uint64_t limit)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00898">thread.h:898</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Atomics</h2>
<p>The atomic32_t and atomic64_t types describe signed 32- and 64-bit integers respectively, which are suitable for being passed to the relevant <code>atomic_*</code> functions. Example of how use an atomic function: </p><div class="fragment"><div class="line"><a class="code" href="thread_8h.html#a76001c2c78446302a9aa4ad103d74116">atomic32_t</a> my_value;       <span class="comment">// declare an atomic 32-bit signed int</span></div>
<div class="line"><a class="code" href="thread_8h.html#ad49900de1ae7bda860e67a808129e589">atomic_set_32</a>(&amp;my_value, 1234);    <span class="comment">// set an integer atomically</span></div>
<div class="line"><a class="code" href="thread_8h.html#aa3b5e21091a75e0e75cfca49c7f01598">atomic_inc_32</a>(&amp;my_value);      <span class="comment">// increment integer atomically</span></div>
<div class="line"><a class="code" href="thread_8h.html#a21b7a2b69f112515950641b4e656dfa9">atomic_dec_32</a>(&amp;my_value);      <span class="comment">// decrement integer atomically</span></div>
<div class="line"><a class="code" href="thread_8h.html#a853b82617fd36250fb02c111dacd8641">atomic_add_32</a>(&amp;my_value, -352);    <span class="comment">// add a value to the atomic integer</span></div>
<div class="ttc" id="athread_8h_html_a21b7a2b69f112515950641b4e656dfa9"><div class="ttname"><a href="thread_8h.html#a21b7a2b69f112515950641b4e656dfa9">atomic_dec_32</a></div><div class="ttdeci">#define atomic_dec_32(x)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00316">thread.h:316</a></div></div>
<div class="ttc" id="athread_8h_html_a76001c2c78446302a9aa4ad103d74116"><div class="ttname"><a href="thread_8h.html#a76001c2c78446302a9aa4ad103d74116">atomic32_t</a></div><div class="ttdeci">#define atomic32_t</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00314">thread.h:314</a></div></div>
<div class="ttc" id="athread_8h_html_a853b82617fd36250fb02c111dacd8641"><div class="ttname"><a href="thread_8h.html#a853b82617fd36250fb02c111dacd8641">atomic_add_32</a></div><div class="ttdeci">#define atomic_add_32(x, y)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00317">thread.h:317</a></div></div>
<div class="ttc" id="athread_8h_html_aa3b5e21091a75e0e75cfca49c7f01598"><div class="ttname"><a href="thread_8h.html#aa3b5e21091a75e0e75cfca49c7f01598">atomic_inc_32</a></div><div class="ttdeci">#define atomic_inc_32(x)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00315">thread.h:315</a></div></div>
<div class="ttc" id="athread_8h_html_ad49900de1ae7bda860e67a808129e589"><div class="ttname"><a href="thread_8h.html#ad49900de1ae7bda860e67a808129e589">atomic_set_32</a></div><div class="ttdeci">#define atomic_set_32(x, y)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00318">thread.h:318</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition in file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a5e863e9ba8b50eafe4f2b3d23bcbe7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e863e9ba8b50eafe4f2b3d23bcbe7c0">&#9670;&nbsp;</a></span>ASSERT_MUTEX_HELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERT_MUTEX_HELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtx</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If compiling with the <code>DEBUG</code> macro set, expands to <a class="el" href="thread_8h.html#a6b2bdfd27350761a2f07e6069f834ee2">VERIFY_MUTEX_HELD()</a>. Otherwise expands to nothing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a6b2bdfd27350761a2f07e6069f834ee2">VERIFY_MUTEX_HELD()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ad2be31cac0a52c8d012ce5e6f387a2e2">ASSERT_MUTEX_NOT_HELD()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01228">1228</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ad2be31cac0a52c8d012ce5e6f387a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2be31cac0a52c8d012ce5e6f387a2e2">&#9670;&nbsp;</a></span>ASSERT_MUTEX_NOT_HELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERT_MUTEX_NOT_HELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtx</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If compiling with the <code>DEBUG</code> macro set, expands to <a class="el" href="thread_8h.html#a63952d5e98e5fac2e1097cda30d65639">VERIFY_MUTEX_NOT_HELD()</a>. Otherwise expands to nothing. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a63952d5e98e5fac2e1097cda30d65639">VERIFY_MUTEX_NOT_HELD()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#a5e863e9ba8b50eafe4f2b3d23bcbe7c0">ASSERT_MUTEX_HELD()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01229">1229</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a76001c2c78446302a9aa4ad103d74116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76001c2c78446302a9aa4ad103d74116">&#9670;&nbsp;</a></span>atomic32_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic32_t&#160;&#160;&#160;volatile int32_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic signed 32-bit integer. You must use this type with the <code>atomic_*_32()</code> family of functions, such as <a class="el" href="thread_8h.html#aa3b5e21091a75e0e75cfca49c7f01598">atomic_inc_32()</a>, <a class="el" href="thread_8h.html#a21b7a2b69f112515950641b4e656dfa9">atomic_dec_32()</a>, <a class="el" href="thread_8h.html#ad49900de1ae7bda860e67a808129e589">atomic_set_32()</a> and <a class="el" href="thread_8h.html#a853b82617fd36250fb02c111dacd8641">atomic_add_32()</a>. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00314">314</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="aa556f1df2e602b1dc318dced31d9b7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa556f1df2e602b1dc318dced31d9b7df">&#9670;&nbsp;</a></span>atomic64_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic64_t&#160;&#160;&#160;volatile int64_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomic signed 64-bit integer. You must use this type with the <code>atomic_*_64()</code> family of functions, such as <a class="el" href="thread_8h.html#afe103fb4cb042d1c0754af99bd7d2c99">atomic_inc_64()</a>, <a class="el" href="thread_8h.html#a4d765d86950dcff9fb10fcd6b0a5527c">atomic_dec_64()</a>, <a class="el" href="thread_8h.html#a6851805657330c5c775a7051c93c876c">atomic_set_64()</a> and <a class="el" href="thread_8h.html#aefe595a4cd13046f1241a36c6e43d668">atomic_add_64()</a>. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00319">319</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a853b82617fd36250fb02c111dacd8641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853b82617fd36250fb02c111dacd8641">&#9670;&nbsp;</a></span>atomic_add_32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_add_32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__sync_add_and_fetch((x), (y))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an arbitrary value to an atomic 32-bit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic32_t to be added to. </td></tr>
    <tr><td class="paramname">y</td><td>32-bit signed integer value to be added to <code>x</code>. Can be negative to perform subtraction instead. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00317">317</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="aefe595a4cd13046f1241a36c6e43d668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefe595a4cd13046f1241a36c6e43d668">&#9670;&nbsp;</a></span>atomic_add_64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_add_64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__sync_add_and_fetch((x), (y))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an arbitrary value to an atomic 64-bit. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic64_t to be added to. </td></tr>
    <tr><td class="paramname">y</td><td>64-bit signed integer value to be added to <code>x</code>. Can be negative to perform subtraction instead. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00322">322</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a21b7a2b69f112515950641b4e656dfa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b7a2b69f112515950641b4e656dfa9">&#9670;&nbsp;</a></span>atomic_dec_32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_dec_32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__sync_add_and_fetch((x), -1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements an atomic 32-bit integer by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic32_t to be decremented. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00316">316</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a4d765d86950dcff9fb10fcd6b0a5527c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d765d86950dcff9fb10fcd6b0a5527c">&#9670;&nbsp;</a></span>atomic_dec_64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_dec_64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__sync_add_and_fetch((x), -1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements an atomic 64-bit integer by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic64_t to be decremented. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00321">321</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="aa3b5e21091a75e0e75cfca49c7f01598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b5e21091a75e0e75cfca49c7f01598">&#9670;&nbsp;</a></span>atomic_inc_32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_inc_32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments an atomic 32-bit integer by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic32_t to be incremented. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00315">315</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="afe103fb4cb042d1c0754af99bd7d2c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe103fb4cb042d1c0754af99bd7d2c99">&#9670;&nbsp;</a></span>atomic_inc_64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_inc_64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;__sync_add_and_fetch((x), 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increments an atomic 64-bit integer by 1. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic64_t to be incremented. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00320">320</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ad49900de1ae7bda860e67a808129e589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49900de1ae7bda860e67a808129e589">&#9670;&nbsp;</a></span>atomic_set_32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_set_32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__atomic_store_n((x), (y), __ATOMIC_RELAXED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an atomic 32-bit integer to a new value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic32_t to be set. </td></tr>
    <tr><td class="paramname">y</td><td>New 32-bit signed integer value to be set in <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00318">318</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a6851805657330c5c775a7051c93c876c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6851805657330c5c775a7051c93c876c">&#9670;&nbsp;</a></span>atomic_set_64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define atomic_set_64</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">y&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;__atomic_store_n((x), (y), __ATOMIC_RELAXED)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an atomic 64-bit integer to a new value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to the atomic64_t to be set. </td></tr>
    <tr><td class="paramname">y</td><td>New 64-bit signed integer value to be set in <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00323">323</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ac9686d1e1b5e62a2ccbab471d8cccf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9686d1e1b5e62a2ccbab471d8cccf64">&#9670;&nbsp;</a></span>curthread</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define curthread&#160;&#160;&#160;GetCurrentThread()</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The calling thread's thread_t handle. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> </dd>
<dd>
<a class="el" href="thread_8h.html#a833ceaa5cf7a525bbd4f96f7fac6e223">curthread_id</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00468">468</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a833ceaa5cf7a525bbd4f96f7fac6e223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833ceaa5cf7a525bbd4f96f7fac6e223">&#9670;&nbsp;</a></span>curthread_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define curthread_id&#160;&#160;&#160;GetCurrentThreadId()</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The calling thread's thread_id_t. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a9a1cbe064d0b759f6e73df45d51488be">thread_id_t</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ac9686d1e1b5e62a2ccbab471d8cccf64">curthread</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00467">467</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="af786b659a08ce46cf82d1ff34e850117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af786b659a08ce46cf82d1ff34e850117">&#9670;&nbsp;</a></span>thread_create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define thread_create</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">thrp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">start_proc, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="thread_8h.html#a39b5159e92fa0e7f699717c49777508d">lacf_thread_create</a>((thrp), (start_proc), (arg), \</div>
<div class="line">        <a class="code" href="log_8h.html#a02a8f73c9408ca73f31f9d97e872b150">log_basename</a>(__FILE__), __LINE__)</div>
<div class="ttc" id="alog_8h_html_a02a8f73c9408ca73f31f9d97e872b150"><div class="ttname"><a href="log_8h.html#a02a8f73c9408ca73f31f9d97e872b150">log_basename</a></div><div class="ttdeci">#define log_basename(f)</div><div class="ttdef"><b>Definition:</b> <a href="log_8h_source.html#l00089">log.h:89</a></div></div>
<div class="ttc" id="athread_8h_html_a39b5159e92fa0e7f699717c49777508d"><div class="ttname"><a href="thread_8h.html#a39b5159e92fa0e7f699717c49777508d">lacf_thread_create</a></div><div class="ttdeci">static bool_t lacf_thread_create(thread_t *thrp, void(*proc)(void *), void *arg, const char *filename, int linenum)</div><div class="ttdef"><b>Definition:</b> <a href="thread_8h_source.html#l00803">thread.h:803</a></div></div>
</div><!-- fragment --><p>Creates a new thread. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thrp</td><td>Return pointer to a thread_t, which will be filled with the thread handle if the thread was started successfully. </td></tr>
    <tr><td class="paramname">proc</td><td>Start function, which will be called by the new thread. When this function returns, the thread terminates. </td></tr>
    <tr><td class="paramname">arg</td><td>Optional pointer, which will be passed to the start function in its first argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>B_TRUE</code> if starting the thread was successful, <code>B_FALSE</code> otherwise. You MUST check the return value and not just assume that starting the thread is always succesful. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00189">189</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ad8e837a74202b264cd0811fd1978ceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e837a74202b264cd0811fd1978ceb2">&#9670;&nbsp;</a></span>THREAD_PRIO_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_HIGH&#160;&#160;&#160;THREAD_PRIORITY_ABOVE_NORMAL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Higher than normal thread scheduling priority. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00991">991</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="aaa96aa6ed8947042ae9719a4e4d1b15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa96aa6ed8947042ae9719a4e4d1b15b">&#9670;&nbsp;</a></span>THREAD_PRIO_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_IDLE&#160;&#160;&#160;THREAD_PRIORITY_IDLE</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum thread scheduling priority - only use for threads which can can accept very long periods of not getting CPU time if the CPU is busy. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00970">970</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a4b96cd9efa7d5c0c433780a05ccac7fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b96cd9efa7d5c0c433780a05ccac7fc">&#9670;&nbsp;</a></span>THREAD_PRIO_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_LOW&#160;&#160;&#160;THREAD_PRIORITY_BELOW_NORMAL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reduced thread scheduling priority, below normal priority. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00980">980</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a581bd0febc37209e1d144ab6b5cc971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581bd0febc37209e1d144ab6b5cc971c">&#9670;&nbsp;</a></span>THREAD_PRIO_NORM</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_NORM&#160;&#160;&#160;THREAD_PRIORITY_NORMAL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normal thread scheduling priority. This is the default for newly created threads. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00986">986</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a35851b93293217dcfd7f0c742f7fe419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35851b93293217dcfd7f0c742f7fe419">&#9670;&nbsp;</a></span>THREAD_PRIO_RT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_RT&#160;&#160;&#160;THREAD_PRIORITY_TIME_CRITICAL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Highest possible thread scheduling priority. Be very careful when using this, as if your thread does a lot of work at this priority, it can starve other threads of CPU time. Use sparingly and only for threads with a known bounded execution time between yields. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01004">1004</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="af3150d44c8e6f8cd82b5ee31c405177f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3150d44c8e6f8cd82b5ee31c405177f">&#9670;&nbsp;</a></span>THREAD_PRIO_VERY_HIGH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_VERY_HIGH&#160;&#160;&#160;THREAD_PRIORITY_HIGHEST</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Very high thread scheduling priority. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00996">996</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a246fc75269629a2471226f2c764b2148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246fc75269629a2471226f2c764b2148">&#9670;&nbsp;</a></span>THREAD_PRIO_VERY_LOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_PRIO_VERY_LOW&#160;&#160;&#160;THREAD_PRIORITY_LOWEST</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Very low thread scheduling priority. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a70e58cfdef7cfba56460fd162302fee0">thread_set_prio()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00975">975</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a6b2bdfd27350761a2f07e6069f834ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2bdfd27350761a2f07e6069f834ee2">&#9670;&nbsp;</a></span>VERIFY_MUTEX_HELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VERIFY_MUTEX_HELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtx</td><td>)</td>
          <td>&#160;&#160;&#160;(void)1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verifies that a <a class="el" href="structmutex__t.html">mutex_t</a> is held by the calling thread. If it isn't, this trips an assertion failure (as if a <a class="el" href="assert_8h.html#a3675cf895544424c921cf6f8f5e91887">VERIFY()</a> check had failed). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a63952d5e98e5fac2e1097cda30d65639">VERIFY_MUTEX_NOT_HELD()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#a5e863e9ba8b50eafe4f2b3d23bcbe7c0">ASSERT_MUTEX_HELD()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00562">562</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a63952d5e98e5fac2e1097cda30d65639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63952d5e98e5fac2e1097cda30d65639">&#9670;&nbsp;</a></span>VERIFY_MUTEX_NOT_HELD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VERIFY_MUTEX_NOT_HELD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtx</td><td>)</td>
          <td>&#160;&#160;&#160;(void)1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The opposite of <a class="el" href="thread_8h.html#a6b2bdfd27350761a2f07e6069f834ee2">VERIFY_MUTEX_HELD()</a>. Due to varying platform support for checking mutex ownership, this cannot be done using a simple stacking such as <code>VERIFY(!MUTEX_HELD(mtx))</code>, as the inner macro wouldn't know what the desired output was and would thus be error-prone when used. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a6b2bdfd27350761a2f07e6069f834ee2">VERIFY_MUTEX_HELD()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ad2be31cac0a52c8d012ce5e6f387a2e2">ASSERT_MUTEX_NOT_HELD()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00563">563</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a0ab38838d7ef7332e8cced210141e72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ab38838d7ef7332e8cced210141e72c">&#9670;&nbsp;</a></span>condvar_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef CONDITION_VARIABLE <a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A condition variable is an object which can be waited on by any number of threads, and signalled by another thread, to notify the waiting threads that a certain condition has been met and/or that the waiting threads' attention is required. A condition variable is always used in conjuction with a mutex. The waiting thread(s) first acquire a mutex to protect a critical section of code. They then wait on a condition variable, which also atomatically relinquishes the mutex, allowing another thread to come acquire the lock and signal the condition. Once signalled, the waiting thread wakes up and atomically acquires the lock (once the signalling thread has relinquished it).</p>
<p>Use <a class="el" href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init()</a> to initialize a condition variable. Once initialized, the object must be destroyed using <a class="el" href="thread_8h.html#a5dd9f72f221894bb9440aee0ed4c0990">cv_destroy()</a>. Waiting on the condition variable can be accomplished using either <a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> or <a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a>. Signalling the condition is performed using either <a class="el" href="thread_8h.html#ac6cfce39bd9db07016198e6d4fe17f60">cv_signal()</a> or <a class="el" href="thread_8h.html#ae146473511da0640f3292e7b0b43d1a6">cv_broadcast()</a>.</p>
<p>Example of how to use a condvar_t: </p><div class="fragment"><div class="line"><a class="code" href="structmutex__t.html">mutex_t</a> my_lock;</div>
<div class="line"><a class="code" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> my_cv;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init</a>(&amp;my_lock);       <span class="comment">// create a lock to control the CV</span></div>
<div class="line"><a class="code" href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init</a>(&amp;my_cv);        <span class="comment">// create the condition variable</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// thread that&#39;s going to signal the condition:</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(&amp;my_lock);  <span class="comment">// grab the lock</span></div>
<div class="line">    <span class="comment">// ... set up some resource that others might be waiting on ...</span></div>
<div class="line">    <a class="code" href="thread_8h.html#ae146473511da0640f3292e7b0b43d1a6">cv_broadcast</a>(&amp;my_lock); <span class="comment">// wake up all waiters</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(&amp;my_lock);   <span class="comment">// release the lock</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// thread that&#39;s going to wait on the condition:</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(&amp;my_lock);          <span class="comment">// grab the lock</span></div>
<div class="line">    <span class="keywordflow">while</span> (!condition_met())</div>
<div class="line">        <a class="code" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait</a>(&amp;my_cv, &amp;my_lock);  <span class="comment">// wait for the CV</span></div>
<div class="line">                        <span class="comment">// to be signalled</span></div>
<div class="line">    <span class="comment">// ... condition fulfilled, use the resource ...</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(&amp;my_lock);           <span class="comment">// release the lock</span></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#a5dd9f72f221894bb9440aee0ed4c0990">cv_destroy()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ac6cfce39bd9db07016198e6d4fe17f60">cv_signal()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ae146473511da0640f3292e7b0b43d1a6">cv_broadcast()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00465">465</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a9a1cbe064d0b759f6e73df45d51488be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1cbe064d0b759f6e73df45d51488be">&#9670;&nbsp;</a></span>thread_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef DWORD <a class="el" href="thread_8h.html#a9a1cbe064d0b759f6e73df45d51488be">thread_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread ID object. This gets returned by macros such as curthread_id. Certain operations require the thread ID, instead of the handle, so this type encapsulates that detail on platforms where there is a distinction between thread handles and IDs (Windows). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a833ceaa5cf7a525bbd4f96f7fac6e223">curthread_id</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00401">401</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ab473f076e05d966f00b78ecb88c8f357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab473f076e05d966f00b78ecb88c8f357">&#9670;&nbsp;</a></span>thread_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef HANDLE <a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread handle object. This gets initialized with a thread handle by a call to <a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create()</a> and is consumed by a variety of other thread-related operations (such as thread_destroy()). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00393">393</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac73a11b7cc2311ca25c66a78e3945dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73a11b7cc2311ca25c66a78e3945dd3">&#9670;&nbsp;</a></span>_lacf_thread_list_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void _lacf_thread_list_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlacf__thread__info__t.html">lacf_thread_info_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Internal. Do not call directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00611">611</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a583893e587676d684012464f6f33508f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583893e587676d684012464f6f33508f">&#9670;&nbsp;</a></span>_lacf_thread_list_fini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void _lacf_thread_list_fini </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Internal. Do not call directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00592">592</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="aba58bd39057ba648bec290cb12d58de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba58bd39057ba648bec290cb12d58de8">&#9670;&nbsp;</a></span>_lacf_thread_list_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void _lacf_thread_list_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Internal. Do not call directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00578">578</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="aee84e92c0685431cf140a4cbf10842cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee84e92c0685431cf140a4cbf10842cf">&#9670;&nbsp;</a></span>_lacf_thread_list_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void _lacf_thread_list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlacf__thread__info__t.html">lacf_thread_info_t</a> *&#160;</td>
          <td class="paramname"><em>ti</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Internal. Do not call directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00624">624</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ae146473511da0640f3292e7b0b43d1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae146473511da0640f3292e7b0b43d1a6">&#9670;&nbsp;</a></span>cv_broadcast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cv_broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals a condition variable to <em>ALL</em> threads waiting on that condition variable (either using <a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> or <a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a>). The threads will wake up (in an unpredictable order), and re-acquire the mutex associated with their <a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> or <a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a> call. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00960">960</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a5dd9f72f221894bb9440aee0ed4c0990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd9f72f221894bb9440aee0ed4c0990">&#9670;&nbsp;</a></span>cv_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cv_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys a condition variable which has been previously initialized using <a class="el" href="thread_8h.html#a827d83b9b8c009b1f2c791b88190fdfd">cv_init()</a>. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00936">936</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a827d83b9b8c009b1f2c791b88190fdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827d83b9b8c009b1f2c791b88190fdfd">&#9670;&nbsp;</a></span>cv_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cv_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a condition variable. Once initialized, a condition variable MUST be destroyed using <a class="el" href="thread_8h.html#a5dd9f72f221894bb9440aee0ed4c0990">cv_destroy()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a5dd9f72f221894bb9440aee0ed4c0990">cv_destroy()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> </dd>
<dd>
<a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00926">926</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ac6cfce39bd9db07016198e6d4fe17f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cfce39bd9db07016198e6d4fe17f60">&#9670;&nbsp;</a></span>cv_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cv_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *&#160;</td>
          <td class="paramname"><em>cv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Signals a condition variable to a single waiting thread. If there are multiple threads currently blocked waiting on the condition variable (either using <a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> or <a class="el" href="thread_8h.html#acef27d2f99d996e8b84a85bd43cfd5de">cv_timedwait()</a>), only <em>ONE</em> of the threads is signalled (which one is unpredictable). </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00948">948</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="acef27d2f99d996e8b84a85bd43cfd5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef27d2f99d996e8b84a85bd43cfd5de">&#9670;&nbsp;</a></span>cv_timedwait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cv_timedwait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks the calling thread until the condition variable is signalled, or until a timeout limit is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>The condition variable to wait on. </td></tr>
    <tr><td class="paramname">mtx</td><td>A <a class="el" href="structmutex__t.html">mutex_t</a> which MUST be currently held by the calling thread. The calling thread atomically relinquishes this mutex and starts monitoring the condition variable. Once the condition is signalled, the thread atomically wakes up and acquires the mutex again, so that when <a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> returns, the lock is acquired again by only the calling thread. </td></tr>
    <tr><td class="paramname">limit</td><td>A deadline in microseconds, by which time the thread will wake up, regardless if the condition has been signalled or not. The limit must be calculated from the time value as returned by the microclock() function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the condition has been signalled before the timeout expired, this function returns zero. Please note that re-acquiring the mutex might extend beyond this time, so don't depend on the return value indicating a hard condition of the timeout limit not having been exceeded. </dd>
<dd>
If the timeout has been reached without the condition becoming signalled, this function returns ETIMEDOUT. If an error occurred, this function returns -1. In both cases, the mutex is re-acquired before returning. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00898">898</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ab61a866c66b3a177a5ef1b31f1fc7ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61a866c66b3a177a5ef1b31f1fc7ed1">&#9670;&nbsp;</a></span>cv_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cv_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#a0ab38838d7ef7332e8cced210141e72c">condvar_t</a> *&#160;</td>
          <td class="paramname"><em>cv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks the calling thread until the condition variable is signalled. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cv</td><td>The condition variable to wait on. </td></tr>
    <tr><td class="paramname">mtx</td><td>A <a class="el" href="structmutex__t.html">mutex_t</a> which MUST be currently held by the calling thread. The calling thread atomically relinquishes this mutex and starts monitoring the condition variable. Once the condition is signalled, the thread atomically wakes up and acquires the mutex again, so that when <a class="el" href="thread_8h.html#ab61a866c66b3a177a5ef1b31f1fc7ed1">cv_wait()</a> returns, the lock is acquired again by only the calling thread. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00868">868</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a6ac09aa4ddc1c4f0c22ee44d80dd19c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac09aa4ddc1c4f0c22ee44d80dd19c7">&#9670;&nbsp;</a></span>lacf_mask_sigpipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lacf_mask_sigpipe </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Configures the calling thread to block SIGPIPE signals on macOS and Linux. Does nothing on Windows. </p>

<p class="definition">Definition at line <a class="el" href="worker_8c_source.html#l00035">35</a> of file <a class="el" href="worker_8c_source.html">worker.c</a>.</p>

</div>
</div>
<a id="a39b5159e92fa0e7f699717c49777508d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b5159e92fa0e7f699717c49777508d">&#9670;&nbsp;</a></span>lacf_thread_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool_t lacf_thread_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thrp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linenum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of <a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create()</a>. Do not call directly, use the <a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create()</a> macro. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00803">803</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a5a0c67fc8f2d8d8eb9528a65ae109ad2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0c67fc8f2d8d8eb9528a65ae109ad2">&#9670;&nbsp;</a></span>lacf_thread_start_routine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DWORD lacf_thread_start_routine </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Internal. Do not call directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8c_source.html#l00040">40</a> of file <a class="el" href="thread_8c_source.html">thread.c</a>.</p>

</div>
</div>
<a id="aedc8471978120bbf92d4560bf1496103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc8471978120bbf92d4560bf1496103">&#9670;&nbsp;</a></span>lacf_threads_fini()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lacf_threads_fini </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks to see if all threads that were created using <a class="el" href="thread_8h.html#af786b659a08ce46cf82d1ff34e850117">thread_create()</a> have been properly disposed of. If not, this trips an assertion failure and lists all threads (including filenames and line numbers where they have been spawned) that weren't properly stopped. You should call this just as your plugin is exiting, to check for leaked threads. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00642">642</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a786e2308c77efa9600eaa81522c1ab32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786e2308c77efa9600eaa81522c1ab32">&#9670;&nbsp;</a></span>mutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mutex_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys <a class="el" href="structmutex__t.html">mutex_t</a> object previously initialized by a call to <a class="el" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00499">499</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a7c7c57534b154632f3ee43b3af22abe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c7c57534b154632f3ee43b3af22abe2">&#9670;&nbsp;</a></span>mutex_enter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mutex_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires a mutex, which has previously been initialized using <a class="el" href="thread_8h.html#ad740bab5dd6dd968f1b026c4b3cbc826">mutex_init()</a>. If the mutex cannot be acquired exclusively by the calling thread, the thread blocks until it can be acquired. Once acquired, the mutex MUST be relinquished by a call to <a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit()</a>. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter()</a> and <a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit()</a> support recursive locking, so once a thread acquires a mutex, it can re-acquire it in nested subroutines without risk of deadlock: <div class="fragment"><div class="line"><a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(mtx);</div>
<div class="line">...</div>
<div class="line">    <span class="comment">// subroutine acquires the lock again - this is safe to do</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(mtx);</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(mtx);</div>
<div class="line">...</div>
<div class="line">mutex_exit(mtx);</div>
</div><!-- fragment --> All calls to <a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter()</a> must be balanced by matching calls to <a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit()</a> before the mutex is finally completely relinquished. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00530">530</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a9147646b7eef9f977404c4192340442f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9147646b7eef9f977404c4192340442f">&#9670;&nbsp;</a></span>mutex_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinquishes a mutex previously acquired by a call to <a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter()</a>. </p><dl class="section note"><dt>Note</dt><dd><a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter()</a> and <a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit()</a> support recursive locking, so once a thread acquires a mutex, it can re-acquire it in nested subroutines without risk of deadlock: <div class="fragment"><div class="line"><a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(mtx);</div>
<div class="line">...</div>
<div class="line">    <span class="comment">// subroutine acquires the lock again - this is safe to do</span></div>
<div class="line">    <a class="code" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter</a>(mtx);</div>
<div class="line">    ...</div>
<div class="line">    <a class="code" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit</a>(mtx);</div>
<div class="line">...</div>
<div class="line">mutex_exit(mtx);</div>
</div><!-- fragment --> All calls to <a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter()</a> must be balanced by matching calls to <a class="el" href="thread_8h.html#a9147646b7eef9f977404c4192340442f">mutex_exit()</a> before the mutex is finally completely relinquished. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a7c7c57534b154632f3ee43b3af22abe2">mutex_enter()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00556">556</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ad740bab5dd6dd968f1b026c4b3cbc826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad740bab5dd6dd968f1b026c4b3cbc826">&#9670;&nbsp;</a></span>mutex_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmutex__t.html">mutex_t</a> *&#160;</td>
          <td class="paramname"><em>mtx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="structmutex__t.html">mutex_t</a> object. The mutex MUST be destroyed using <a class="el" href="thread_8h.html#a786e2308c77efa9600eaa81522c1ab32">mutex_destroy()</a> to avoid leaking memory. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a786e2308c77efa9600eaa81522c1ab32">mutex_destroy()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00488">488</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a9445f660555e36865aeb606c614e2aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9445f660555e36865aeb606c614e2aba">&#9670;&nbsp;</a></span>rwmutex_can_enter_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool_t rwmutex_can_enter_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrwlock__waiter__t.html">rwlock_waiter_t</a> *&#160;</td>
          <td class="paramname"><em>wt_self</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Internal. Do not call directly. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01100">1100</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a5bf1a60ece7f1aaa11c711c304f678fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf1a60ece7f1aaa11c711c304f678fd">&#9670;&nbsp;</a></span>rwmutex_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rwmutex_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys an <a class="el" href="structrwmutex__t.html">rwmutex_t</a> that was previously initialized <a class="el" href="thread_8h.html#a377021479ab80f7873fd382ae111222d">rwmutex_init()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a377021479ab80f7873fd382ae111222d">rwmutex_init()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01075">1075</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a32eb36ceb0203220867021ceac4bc2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32eb36ceb0203220867021ceac4bc2ef">&#9670;&nbsp;</a></span>rwmutex_enter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rwmutex_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool_t&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Acquires an <a class="el" href="structrwmutex__t.html">rwmutex_t</a> in either read or write mode. The lock can be simultaneously held in read mode by any number of threads. However, in write mode, the lock can only be held by a single thread. If the lock cannot be acquired immediately, the calling thread is blocked until successful.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="structrwmutex__t.html">rwmutex_t</a> does NOT support recursion. An attempt to acquire the lock multiple times from the same thread can cause an assertion failure or even deadlock.</dd></dl>
<h3><a class="anchor" id="autotoc_md12"></a>
Locking Order</h3>
<p><a class="el" href="structrwmutex__t.html">rwmutex_t</a> implements deterministic locking order. If the lock is currently held by one or more readers and another thread attempts to acquire the lock in write (exclusive) mode, the calling thread is blocked until all existing read locks are relinquished. Furthermore, any newly arriving locking attempts will queue up "behind" any preceding attempts and block. The queue of pending locks is then cleared in order of arrival. Writers can only enter one by one, while a "batched up" group of readers can enter simultaneously. This prevents lock starvation of writers in the presence of a large number of readers and vice versa.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rw</td><td>The mutex to acquire. </td></tr>
    <tr><td class="paramname">write</td><td>Sets whether the lock should be acquired in write (<code>write=B_TRUE</code>) or read (<code>write=B_FALSE</code>) mode. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01143">1143</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ac83275c541a5fd2a13ecce03457e59ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83275c541a5fd2a13ecce03457e59ca">&#9670;&nbsp;</a></span>rwmutex_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rwmutex_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Relinquishes a previously acquired read- or write lock of an <a class="el" href="structrwmutex__t.html">rwmutex_t</a>. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01200">1200</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="ab54461f822e127a882d6b144abcd9e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54461f822e127a882d6b144abcd9e1b">&#9670;&nbsp;</a></span>rwmutex_held_write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool_t rwmutex_held_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><code>B_TRUE</code> if the <a class="el" href="structrwmutex__t.html">rwmutex_t</a> is currently held by the calling thread in write mode, <code>B_FALSE</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This doesn't determine whether the calling thread is currently holding the <a class="el" href="structrwmutex__t.html">rwmutex_t</a> in read mode. Read mode acquisitions of the <a class="el" href="structrwmutex__t.html">rwmutex_t</a> do not retain any ownership information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01091">1091</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a377021479ab80f7873fd382ae111222d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377021479ab80f7873fd382ae111222d">&#9670;&nbsp;</a></span>rwmutex_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rwmutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="structrwmutex__t.html">rwmutex_t</a>. The mutex must be destroyed using <a class="el" href="thread_8h.html#a5bf1a60ece7f1aaa11c711c304f678fd">rwmutex_destroy()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="thread_8h.html#a5bf1a60ece7f1aaa11c711c304f678fd">rwmutex_destroy()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01061">1061</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="af25b7a9564357bc92b2f89902ca175f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25b7a9564357bc92b2f89902ca175f1">&#9670;&nbsp;</a></span>rwmutex_upgrade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rwmutex_upgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrwmutex__t.html">rwmutex_t</a> *&#160;</td>
          <td class="paramname"><em>rw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>"Upgrades" a currently held read lock into a write lock. </p>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01218">1218</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a7a65ac5862e099f0e7812957d43a3a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a65ac5862e099f0e7812957d43a3a1c">&#9670;&nbsp;</a></span>thread_join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void thread_join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a> *&#160;</td>
          <td class="paramname"><em>thrp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Waits for a thread to exit. After this function returns, the passed thread has exited and its resources can be safely disposed of. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thrp</td><td>A pointer to a thread_t identifying the thread for which to wait. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function doesn't <em>cause</em> the target thread to exit, it only blocks the calling thread until the target thread has exited. You should notify the target thread using other means to exit before calling <a class="el" href="thread_8h.html#a7a65ac5862e099f0e7812957d43a3a1c">thread_join()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00836">836</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a6eed8148cb94fb7395f4c342e4e365f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eed8148cb94fb7395f4c342e4e365f1">&#9670;&nbsp;</a></span>thread_set_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void thread_set_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the name of the calling thread. This is useful for debugging purposes, since the thread name is easily visible in a debugger or process analysis tool. </p><dl class="section note"><dt>Note</dt><dd>This function is only supported on macOS and Linux. Furthermore, on Linux, names longer than 16 bytes (including the terminating NUL character) will be truncated to 16 bytes. On Windows, calling this function does nothing. </dd></dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l00852">852</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
<a id="a70e58cfdef7cfba56460fd162302fee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e58cfdef7cfba56460fd162302fee0">&#9670;&nbsp;</a></span>thread_set_prio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void thread_set_prio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thread_8h.html#ab473f076e05d966f00b78ecb88c8f357">thread_t</a>&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the scheduling priority of a thread. The exact implementation is platform dependant:</p><ul>
<li>On Linux, this calls <code>pthread_setschedparam()</code> with a policy of <code>SCHED_OTHER</code>.</li>
<li>On macOS, due to a bug in the thread schedling behavior under Rosetta x86 emulation, thread scheduling is disabled.</li>
<li>On Windows, this calls <code>SetThreadPriority()</code>.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prio</td><td>Must be one of the <code>THREAD_PRIO_*</code> constants. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="thread_8h_source.html#l01017">1017</a> of file <a class="el" href="thread_8h_source.html">thread.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
