<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libacfutils: acfutils/list.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libacfutils
   </div>
   <div id="projectbrief">A general purpose library of utility functions designed to make it easier to develop addons for the X-Plane flight simulator.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2f18166f86af4fcbeaddefb60d5355e9.html">acfutils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">list.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="core_8h_source.html">core.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="list__impl_8h_source.html">list_impl.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for list.h:</div>
<div class="dyncontent">
<div class="center"><img src="list_8h__incl.png" border="0" usemap="#aacfutils_2list_8h" alt=""/></div>
<map name="aacfutils_2list_8h" id="aacfutils_2list_8h">
<area shape="rect" title=" " alt="" coords="143,5,250,32"/>
<area shape="rect" href="core_8h.html" title=" " alt="" coords="115,80,177,107"/>
<area shape="rect" href="list__impl_8h.html" title=" " alt="" coords="210,80,301,107"/>
<area shape="rect" title=" " alt="" coords="5,155,76,181"/>
<area shape="rect" href="libconfig_8h_source.html" title=" " alt="" coords="101,155,191,181"/>
<area shape="rect" title=" " alt="" coords="215,155,311,181"/>
</map>
</div>
</div>
<p><a href="list_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a71f3147d098f96b66d9d681adacd8db0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a71f3147d098f96b66d9d681adacd8db0">list_create</a> (<a class="el" href="structlist__t.html">list_t</a> *, size_t, size_t)</td></tr>
<tr class="separator:a71f3147d098f96b66d9d681adacd8db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461c916fb70af664b31a7b3283d5d184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a461c916fb70af664b31a7b3283d5d184">list_destroy</a> (<a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:a461c916fb70af664b31a7b3283d5d184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85021fef0c7ec8bc3798e481c47563a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a85021fef0c7ec8bc3798e481c47563a9">list_insert_after</a> (<a class="el" href="structlist__t.html">list_t</a> *, void *, void *)</td></tr>
<tr class="separator:a85021fef0c7ec8bc3798e481c47563a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88818788e6336a1f69250abd0e684fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a88818788e6336a1f69250abd0e684fb2">list_insert_before</a> (<a class="el" href="structlist__t.html">list_t</a> *, void *, void *)</td></tr>
<tr class="separator:a88818788e6336a1f69250abd0e684fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79859934c37c8c961b5b33cc007e1ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ab79859934c37c8c961b5b33cc007e1ce">list_insert_head</a> (<a class="el" href="structlist__t.html">list_t</a> *, void *)</td></tr>
<tr class="separator:ab79859934c37c8c961b5b33cc007e1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa117e9763b09876a5ee6bcedd9b06a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#afaa117e9763b09876a5ee6bcedd9b06a">list_insert_tail</a> (<a class="el" href="structlist__t.html">list_t</a> *, void *)</td></tr>
<tr class="separator:afaa117e9763b09876a5ee6bcedd9b06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e3f5504ba93e11090dd7b85013e9a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ae8e3f5504ba93e11090dd7b85013e9a6">list_remove</a> (<a class="el" href="structlist__t.html">list_t</a> *, void *)</td></tr>
<tr class="separator:ae8e3f5504ba93e11090dd7b85013e9a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67938c91a36dbb8963d9a18ac2af1c22"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a67938c91a36dbb8963d9a18ac2af1c22">list_remove_head</a> (<a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:a67938c91a36dbb8963d9a18ac2af1c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa815d7427f7d2acf9396c3a998ccedea"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#aa815d7427f7d2acf9396c3a998ccedea">list_remove_tail</a> (<a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:aa815d7427f7d2acf9396c3a998ccedea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed7aba7f17bec99bbbeb8c74b768c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a7ed7aba7f17bec99bbbeb8c74b768c43">list_move_tail</a> (<a class="el" href="structlist__t.html">list_t</a> *, <a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:a7ed7aba7f17bec99bbbeb8c74b768c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19992f20adf9d4f271feffa6cbb532c1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a19992f20adf9d4f271feffa6cbb532c1">list_head</a> (const <a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:a19992f20adf9d4f271feffa6cbb532c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364c3cdd1938f1a6613140ea030c0597"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a364c3cdd1938f1a6613140ea030c0597">list_tail</a> (const <a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:a364c3cdd1938f1a6613140ea030c0597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bce03174cd33b6f6cc191c53cbfc48e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a9bce03174cd33b6f6cc191c53cbfc48e">list_next</a> (const <a class="el" href="structlist__t.html">list_t</a> *, const void *)</td></tr>
<tr class="separator:a9bce03174cd33b6f6cc191c53cbfc48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45616756545f942cacb4824413033ee5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a45616756545f942cacb4824413033ee5">list_prev</a> (const <a class="el" href="structlist__t.html">list_t</a> *, const void *)</td></tr>
<tr class="separator:a45616756545f942cacb4824413033ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033a1c065f587d20969ed582bafcff48"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a033a1c065f587d20969ed582bafcff48">list_get_i</a> (const <a class="el" href="structlist__t.html">list_t</a> *, size_t)</td></tr>
<tr class="separator:a033a1c065f587d20969ed582bafcff48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9c4f25256d7aecc62d66d505a362b4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a4b9c4f25256d7aecc62d66d505a362b4">list_is_empty</a> (const <a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:a4b9c4f25256d7aecc62d66d505a362b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84901bde4c62995e04dc00ac1c51ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#ad84901bde4c62995e04dc00ac1c51ce7">list_link_init</a> (<a class="el" href="structlist__node__t.html">list_node_t</a> *)</td></tr>
<tr class="separator:ad84901bde4c62995e04dc00ac1c51ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7352e3ed550eb624829c7d19f54439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a1b7352e3ed550eb624829c7d19f54439">list_link_replace</a> (<a class="el" href="structlist__node__t.html">list_node_t</a> *, <a class="el" href="structlist__node__t.html">list_node_t</a> *)</td></tr>
<tr class="separator:a1b7352e3ed550eb624829c7d19f54439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d2b11af3a53a2616b510339506560c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#a25d2b11af3a53a2616b510339506560c">list_link_active</a> (const <a class="el" href="structlist__node__t.html">list_node_t</a> *)</td></tr>
<tr class="separator:a25d2b11af3a53a2616b510339506560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc65c68f9f4ff6ba3ccb7f417dc0e915"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="list_8h.html#adc65c68f9f4ff6ba3ccb7f417dc0e915">list_count</a> (const <a class="el" href="structlist__t.html">list_t</a> *)</td></tr>
<tr class="separator:adc65c68f9f4ff6ba3ccb7f417dc0e915"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a general-purpose doubly-linked list system. It is designed to be easy to integrate into pre-existing data structures and has many functions to manipulate and examine the linked list. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structlist__t.html">list_t</a> </dd>
<dd>
<a class="el" href="list_8h.html#a71f3147d098f96b66d9d681adacd8db0">list_create()</a> </dd></dl>

<p class="definition">Definition in file <a class="el" href="list_8h_source.html">list.h</a>.</p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="adc65c68f9f4ff6ba3ccb7f417dc0e915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc65c68f9f4ff6ba3ccb7f417dc0e915">&#9670;&nbsp;</a></span>list_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t list_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of items in the list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00543">543</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a71f3147d098f96b66d9d681adacd8db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f3147d098f96b66d9d681adacd8db0">&#9670;&nbsp;</a></span>list_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new linked list. This must be called before a <a class="el" href="structlist__t.html">list_t</a> is used. When you are done with the linked list, you must deinitialize it using <a class="el" href="list_8h.html#a461c916fb70af664b31a7b3283d5d184">list_destroy()</a>.</p>
<p>Data structures to be held in the linked list must have a <a class="el" href="structlist__node__t.html">list_node_t</a> field added to them. This is where the linked list will keep its lists node references. If you want to hold an object in more than one linked list, you will need a separate <a class="el" href="structlist__node__t.html">list_node_t</a> for each linked list. A single <a class="el" href="structlist__node__t.html">list_node_t</a> cannot be shared at the same time between multiple lists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The linked list to be initialized. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the objects to be referenced in the linked list. This is mostly meant for error-checking for the placement of the list node. </td></tr>
    <tr><td class="paramname">offset</td><td>Offset within the data structures that will be contained in the <a class="el" href="structlist__t.html">list_t</a> to where the <a class="el" href="structlist__node__t.html">list_node_t</a> field is. You should use the standard <code>offsetof()</code> for this purpose.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md24"></a>
Example:</h4>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">   <span class="keywordtype">int</span>         foo;</div>
<div class="line">   <span class="keywordtype">float</span>       bar;</div>
<div class="line">   <a class="code" href="structlist__node__t.html">list_node_t</a> node;</div>
<div class="line">} my_data_t;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// initializing a list_t to contain my_data_t structures:</span></div>
<div class="line"><a class="code" href="structlist__t.html">list_t</a> my_list;</div>
<div class="line"><a class="code" href="list_8h.html#a71f3147d098f96b66d9d681adacd8db0">list_create</a>(&amp;my_list, <span class="keyword">sizeof</span> (my_data_t), offsetof(my_data_t, node));</div>
<div class="ttc" id="alist_8h_html_a71f3147d098f96b66d9d681adacd8db0"><div class="ttname"><a href="list_8h.html#a71f3147d098f96b66d9d681adacd8db0">list_create</a></div><div class="ttdeci">void list_create(list_t *, size_t, size_t)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00113">list.c:113</a></div></div>
<div class="ttc" id="astructlist__node__t_html"><div class="ttname"><a href="structlist__node__t.html">list_node_t</a></div></div>
<div class="ttc" id="astructlist__t_html"><div class="ttname"><a href="structlist__t.html">list_t</a></div></div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="list_8h.html#a461c916fb70af664b31a7b3283d5d184">list_destroy()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00113">113</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a461c916fb70af664b31a7b3283d5d184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461c916fb70af664b31a7b3283d5d184">&#9670;&nbsp;</a></span>list_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys a <a class="el" href="structlist__t.html">list_t</a> structure which was previously initialized using <a class="el" href="list_8h.html#a71f3147d098f96b66d9d681adacd8db0">list_create()</a>. The list MUST be empty before this is done, otherwise an assertion failure is tripped. </p><dl class="section note"><dt>Note</dt><dd>This doesn't call free() on the data structure. It simply cleans it up and frees any internal resources. If you allocated the <a class="el" href="structlist__t.html">list_t</a> previously using malloc() or similar, you must free() the data yourself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00136">136</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a033a1c065f587d20969ed582bafcff48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033a1c065f587d20969ed582bafcff48">&#9670;&nbsp;</a></span>list_get_i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_get_i </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an iterative search through the list to retrieve a particular element in the list in order. </p><dl class="section note"><dt>Note</dt><dd>This is an expensive operation, as it performs an O(n) search (iterating through the list), which can take long on very large lists. If you need frequent random access to items in large lists, you should consider using a simple array instead of a linked list. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the item in the list (counting from 0). This <b>must</b> be less than the total number of items in the list as returned by <a class="el" href="list_8h.html#adc65c68f9f4ff6ba3ccb7f417dc0e915">list_count()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The i'th object inside of the list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00412">412</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a19992f20adf9d4f271feffa6cbb532c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19992f20adf9d4f271feffa6cbb532c1">&#9670;&nbsp;</a></span>list_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_head </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The first object in the list. If the list is empty, returns NULL instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00292">292</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a85021fef0c7ec8bc3798e481c47563a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85021fef0c7ec8bc3798e481c47563a9">&#9670;&nbsp;</a></span>list_insert_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_insert_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nobject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new object immediately after another object into a linked list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list into which the insert will be performed. </td></tr>
    <tr><td class="paramname">object</td><td>The preceding object, after which the new object will be inserted. </td></tr>
    <tr><td class="paramname">nobject</td><td>The new object being inserted. It will be inserted immediately following <code>object</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The new object being inserted must NOT already be a member of this list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00159">159</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a88818788e6336a1f69250abd0e684fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88818788e6336a1f69250abd0e684fb2">&#9670;&nbsp;</a></span>list_insert_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>nobject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new object immediately in front of another object into a linked list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list into which the insert will be performed. </td></tr>
    <tr><td class="paramname">object</td><td>The following object, in front of which the new object will be inserted. </td></tr>
    <tr><td class="paramname">nobject</td><td>The new object being inserted. It will be inserted immediately in front of <code>object</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The new object being inserted must NOT already be a member of this list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00181">181</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="ab79859934c37c8c961b5b33cc007e1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab79859934c37c8c961b5b33cc007e1ce">&#9670;&nbsp;</a></span>list_insert_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_insert_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an object at the head (start) of a linked list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list into which the insert will be performed. </td></tr>
    <tr><td class="paramname">object</td><td>The object to be inserted at the head of the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The new object being inserted must NOT already be a member of this list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00199">199</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="afaa117e9763b09876a5ee6bcedd9b06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa117e9763b09876a5ee6bcedd9b06a">&#9670;&nbsp;</a></span>list_insert_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_insert_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts an object at the tail (end) of a linked list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list into which the insert will be performed. </td></tr>
    <tr><td class="paramname">object</td><td>The object to be inserted at the head of the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The new object being inserted must NOT already be a member of this list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00213">213</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a4b9c4f25256d7aecc62d66d505a362b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9c4f25256d7aecc62d66d505a362b4">&#9670;&nbsp;</a></span>list_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the list is empty, otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00534">534</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a25d2b11af3a53a2616b510339506560c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d2b11af3a53a2616b510339506560c">&#9670;&nbsp;</a></span>list_link_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int list_link_active </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__node__t.html">list_node_t</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if the given <a class="el" href="structlist__node__t.html">list_node_t</a> is active, i.e. the object containing the node is currently part of a list. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>For this function to work properly, the object containing the <a class="el" href="structlist__node__t.html">list_node_t</a> must either have been pre-initialized to all zeros during allocation, or you have explicitly initialized the <a class="el" href="structlist__node__t.html">list_node_t</a> itself using <a class="el" href="list_8h.html#ad84901bde4c62995e04dc00ac1c51ce7">list_link_init()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00525">525</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="ad84901bde4c62995e04dc00ac1c51ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84901bde4c62995e04dc00ac1c51ce7">&#9670;&nbsp;</a></span>list_link_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_link_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__node__t.html">list_node_t</a> *&#160;</td>
          <td class="paramname"><em>link</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="structlist__node__t.html">list_node_t</a> so that subsequent calls to <a class="el" href="list_8h.html#a25d2b11af3a53a2616b510339506560c">list_link_active()</a> can determine the activity status of that node correctly. This is equivalent to just setting the contents of the node to NULL, so you can achieve the same effect of this function by simply allocating the structure containing the <a class="el" href="structlist__node__t.html">list_node_t</a> using an allocation function which zeros out the memory contents during allocation (such as calloc()). </p>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00510">510</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a1b7352e3ed550eb624829c7d19f54439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7352e3ed550eb624829c7d19f54439">&#9670;&nbsp;</a></span>list_link_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_link_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__node__t.html">list_node_t</a> *&#160;</td>
          <td class="paramname"><em>lold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlist__node__t.html">list_node_t</a> *&#160;</td>
          <td class="paramname"><em>lnew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces an object in a linked list with another object, without the need to have a reference to the original <a class="el" href="structlist__t.html">list_t</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lold</td><td>A pointer to the <a class="el" href="structlist__node__t.html">list_node_t</a> of the old object, which is to be replaced by the new object. This object MUST be in a list (<a class="el" href="list_8h.html#a25d2b11af3a53a2616b510339506560c">list_link_active()</a> returns true). </td></tr>
    <tr><td class="paramname">lnew</td><td>A pointer to the <a class="el" href="structlist__node__t.html">list_node_t</a> of the new object, which is to replace the old object. This object must NOT be in a list (<a class="el" href="list_8h.html#a25d2b11af3a53a2616b510339506560c">list_link_active()</a> returns false). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The two objects must be of the same type and hold their <a class="el" href="structlist__node__t.html">list_node_t</a> at the exact same offset within the parent structure. This function is NOT meant to replace one type of object with a different type of object within the same list. </dd></dl>
<h4><a class="anchor" id="autotoc_md29"></a>
Example</h4>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">   <span class="keywordtype">int</span>         foo;</div>
<div class="line">   <span class="keywordtype">float</span>       bar;</div>
<div class="line">   <a class="code" href="structlist__node__t.html">list_node_t</a> node;</div>
<div class="line">} my_data_t;</div>
<div class="line">my_data_t *old_object;</div>
<div class="line">[...]</div>
<div class="line"><span class="comment">// old_object gets placed into a list and we want to replace it</span></div>
<div class="line">[...]</div>
<div class="line">my_data_t *new_object;</div>
<div class="line"><a class="code" href="list_8h.html#a1b7352e3ed550eb624829c7d19f54439">list_link_replace</a>(&amp;old_object-&gt;node, &amp;new_object-&gt;node);</div>
<div class="line"><span class="comment">// now old_object is no longer in its containing list and new_object</span></div>
<div class="line"><span class="comment">// took its place</span></div>
<div class="ttc" id="alist_8h_html_a1b7352e3ed550eb624829c7d19f54439"><div class="ttname"><a href="list_8h.html#a1b7352e3ed550eb624829c7d19f54439">list_link_replace</a></div><div class="ttdeci">void list_link_replace(list_node_t *, list_node_t *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00489">list.c:489</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00489">489</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a7ed7aba7f17bec99bbbeb8c74b768c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed7aba7f17bec99bbbeb8c74b768c43">&#9670;&nbsp;</a></span>list_move_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_move_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfers the contents of one list to another, by appending them. This is faster than moving items one by one, as it simply manipulates the list references for the first and last item. Thus this is a constant-time algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Destination list to which to append all items in <code>src</code>. </td></tr>
    <tr><td class="paramname">src</td><td>Source list, from which to append all items to the end of <code>dst</code>. Afterwards, the <code>src</code> list will be empty. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00436">436</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a9bce03174cd33b6f6cc191c53cbfc48e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bce03174cd33b6f6cc191c53cbfc48e">&#9670;&nbsp;</a></span>list_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_next </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates through the list forward (towards the tail) by 1 object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list being iterated. </td></tr>
    <tr><td class="paramname">object</td><td>The object from which the next object will be returned. This must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next object following <code>object</code> in the second argument. If there are no more objects following <code>object</code>, returns NULL instead. </dd></dl>
<h4><a class="anchor" id="autotoc_md27"></a>
Example</h4>
<p>Iterating through a list forwards: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (my_data_t *data = <a class="code" href="list_8h.html#a19992f20adf9d4f271feffa6cbb532c1">list_head</a>(&amp;my_list); data != NULL;</div>
<div class="line">    data = <a class="code" href="list_8h.html#a9bce03174cd33b6f6cc191c53cbfc48e">list_next</a>(&amp;my_list, data)) {</div>
<div class="line">   <span class="comment">// do something with data</span></div>
<div class="line">}</div>
<div class="ttc" id="alist_8h_html_a19992f20adf9d4f271feffa6cbb532c1"><div class="ttname"><a href="list_8h.html#a19992f20adf9d4f271feffa6cbb532c1">list_head</a></div><div class="ttdeci">void * list_head(const list_t *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00292">list.c:292</a></div></div>
<div class="ttc" id="alist_8h_html_a9bce03174cd33b6f6cc191c53cbfc48e"><div class="ttname"><a href="list_8h.html#a9bce03174cd33b6f6cc191c53cbfc48e">list_next</a></div><div class="ttdeci">void * list_next(const list_t *, const void *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00344">list.c:344</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If you plan on removing items from the list while iterating through it, be careful to structure your <code>for()</code> loop correctly so as to avoid using a removed reference for the iteration. Grab the next item reference early, before potentially removing the current item: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (my_data_t *data = <a class="code" href="list_8h.html#a19992f20adf9d4f271feffa6cbb532c1">list_head</a>(&amp;my_list), *next_data = NULL;</div>
<div class="line">    data != NULL; data = next_data) {</div>
<div class="line">   <span class="comment">// grab next_data now, before we remove the current item</span></div>
<div class="line">   next_data = <a class="code" href="list_8h.html#a9bce03174cd33b6f6cc191c53cbfc48e">list_next</a>(&amp;my_list, data);</div>
<div class="line">   <span class="keywordflow">if</span> (should_remove(data)) {</div>
<div class="line">       <span class="comment">// now we can safely remove the item from the list</span></div>
<div class="line">       <a class="code" href="list_8h.html#ae8e3f5504ba93e11090dd7b85013e9a6">list_remove</a>(&amp;my_list, data);</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="alist_8h_html_ae8e3f5504ba93e11090dd7b85013e9a6"><div class="ttname"><a href="list_8h.html#ae8e3f5504ba93e11090dd7b85013e9a6">list_remove</a></div><div class="ttdeci">void list_remove(list_t *, void *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00226">list.c:226</a></div></div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00344">344</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a45616756545f942cacb4824413033ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45616756545f942cacb4824413033ee5">&#9670;&nbsp;</a></span>list_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates through the list backward (towards the head) by 1 object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list being iterated. </td></tr>
    <tr><td class="paramname">object</td><td>The object from which the previous object will be returned. This must not be NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest object preceding <code>object</code> in the second argument. If there are no more objects preceding <code>object</code>, returns NULL instead. </dd></dl>
<h4><a class="anchor" id="autotoc_md28"></a>
Example</h4>
<p>Iterating through a list backwards: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (my_data_t *data = <a class="code" href="list_8h.html#a364c3cdd1938f1a6613140ea030c0597">list_tail</a>(&amp;my_list); data != NULL;</div>
<div class="line">    data = <a class="code" href="list_8h.html#a45616756545f942cacb4824413033ee5">list_prev</a>(&amp;my_list, data)) {</div>
<div class="line">   <span class="comment">// do something with data</span></div>
<div class="line">}</div>
<div class="ttc" id="alist_8h_html_a364c3cdd1938f1a6613140ea030c0597"><div class="ttname"><a href="list_8h.html#a364c3cdd1938f1a6613140ea030c0597">list_tail</a></div><div class="ttdeci">void * list_tail(const list_t *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00304">list.c:304</a></div></div>
<div class="ttc" id="alist_8h_html_a45616756545f942cacb4824413033ee5"><div class="ttname"><a href="list_8h.html#a45616756545f942cacb4824413033ee5">list_prev</a></div><div class="ttdeci">void * list_prev(const list_t *, const void *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00388">list.c:388</a></div></div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>If you plan on removing items from the list while iterating through it, be careful to structure your <code>for()</code> loop correctly so as to avoid using a removed reference for the iteration. Grab the next item reference early, before potentially removing the current item: <div class="fragment"><div class="line"><span class="keywordflow">for</span> (my_data_t *data = <a class="code" href="list_8h.html#a364c3cdd1938f1a6613140ea030c0597">list_tail</a>(&amp;my_list), *prev_data = NULL;</div>
<div class="line">    data != NULL; data = prev_data) {</div>
<div class="line">   <span class="comment">// grab prev_data now, before we remove the current item</span></div>
<div class="line">   prev_data = <a class="code" href="list_8h.html#a45616756545f942cacb4824413033ee5">list_prev</a>(&amp;my_list, data);</div>
<div class="line">   <span class="keywordflow">if</span> (should_remove(data)) {</div>
<div class="line">       <span class="comment">// now we can safely remove the item from the list</span></div>
<div class="line">       <a class="code" href="list_8h.html#ae8e3f5504ba93e11090dd7b85013e9a6">list_remove</a>(&amp;my_list, data);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --> </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00388">388</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="ae8e3f5504ba93e11090dd7b85013e9a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e3f5504ba93e11090dd7b85013e9a6">&#9670;&nbsp;</a></span>list_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an object from the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list from which the object is to be removed. </td></tr>
    <tr><td class="paramname">object</td><td>The object to be removed from the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The object being removed <b>must</b> be a member of this list. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00226">226</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a67938c91a36dbb8963d9a18ac2af1c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67938c91a36dbb8963d9a18ac2af1c22">&#9670;&nbsp;</a></span>list_remove_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an object from the head (start) of the list. </p><dl class="section return"><dt>Returns</dt><dd>The object which was removed from the head of the list. If the list was already empty, returns NULL instead.</dd></dl>
<h4><a class="anchor" id="autotoc_md25"></a>
Example</h4>
<p>This function is commonly used to empty out a list by removing all members, like this: </p><div class="fragment"><div class="line">my_data_t *data;</div>
<div class="line"><span class="keywordflow">while</span> ((data = <a class="code" href="list_8h.html#a67938c91a36dbb8963d9a18ac2af1c22">list_remove_head</a>(&amp;my_list)) != NULL) {</div>
<div class="line">   free(data);</div>
<div class="line">}</div>
<div class="ttc" id="alist_8h_html_a67938c91a36dbb8963d9a18ac2af1c22"><div class="ttname"><a href="list_8h.html#a67938c91a36dbb8963d9a18ac2af1c22">list_remove_head</a></div><div class="ttdeci">void * list_remove_head(list_t *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00251">list.c:251</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00251">251</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="aa815d7427f7d2acf9396c3a998ccedea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa815d7427f7d2acf9396c3a998ccedea">&#9670;&nbsp;</a></span>list_remove_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_remove_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes an object from the tail (end) of the list. </p><dl class="section return"><dt>Returns</dt><dd>The object which was removed from the tail of the list. If the list was already empty, returns NULL instead.</dd></dl>
<h4><a class="anchor" id="autotoc_md26"></a>
Example</h4>
<p>This function is commonly used to empty out a list by removing all members, like this: </p><div class="fragment"><div class="line">my_data_t *data;</div>
<div class="line"><span class="keywordflow">while</span> ((data = <a class="code" href="list_8h.html#aa815d7427f7d2acf9396c3a998ccedea">list_remove_tail</a>(&amp;my_list)) != NULL) {</div>
<div class="line">   free(data);</div>
<div class="line">}</div>
<div class="ttc" id="alist_8h_html_aa815d7427f7d2acf9396c3a998ccedea"><div class="ttname"><a href="list_8h.html#aa815d7427f7d2acf9396c3a998ccedea">list_remove_tail</a></div><div class="ttdeci">void * list_remove_tail(list_t *)</div><div class="ttdef"><b>Definition:</b> <a href="list_8c_source.html#l00277">list.c:277</a></div></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00277">277</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
<a id="a364c3cdd1938f1a6613140ea030c0597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364c3cdd1938f1a6613140ea030c0597">&#9670;&nbsp;</a></span>list_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* list_tail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlist__t.html">list_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The last object in the list. If the list is empty, returns NULL instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="list_8c_source.html#l00304">304</a> of file <a class="el" href="list_8c_source.html">list.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
